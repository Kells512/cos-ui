/* tslint:disable */
/* eslint-disable */
/**
 * Kafka Service Fleet Manager
 * Kafka Service Fleet Manager is a Rest API to manage kafka instances and connectors.
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * _Amazon Web Services_ specific settings of a cluster. 
 * @export
 * @interface AWS
 */
export interface AWS {
    /**
     * AWS access key identifier. 
     * @type {string}
     * @memberof AWS
     */
    access_key_id?: string;
    /**
     * AWS account identifier. 
     * @type {string}
     * @memberof AWS
     */
    account_id?: string;
    /**
     * AWS secret access key. 
     * @type {string}
     * @memberof AWS
     */
    secret_access_key?: string;
    /**
     * SubnetIDs are the subnet ids to be used when installing the cluster. 
     * @type {Array<string>}
     * @memberof AWS
     */
    subnet_ids?: Array<string>;
}
/**
 * Specification for different classes of nodes inside a flavour. 
 * @export
 * @interface AWSFlavour
 */
export interface AWSFlavour {
    /**
     * AWS default instance type for the worker volume.  User can be overridden specifying in the cluster itself a type for compute node. 
     * @type {string}
     * @memberof AWSFlavour
     */
    compute_instance_type?: string;
    /**
     * AWS default instance type for the infra volume. 
     * @type {string}
     * @memberof AWSFlavour
     */
    infra_instance_type?: string;
    /**
     * 
     * @type {AWSVolume}
     * @memberof AWSFlavour
     */
    infra_volume?: AWSVolume;
    /**
     * AWS default instance type for the master volume. 
     * @type {string}
     * @memberof AWSFlavour
     */
    master_instance_type?: string;
    /**
     * 
     * @type {AWSVolume}
     * @memberof AWSFlavour
     */
    master_volume?: AWSVolume;
    /**
     * 
     * @type {AWSVolume}
     * @memberof AWSFlavour
     */
    worker_volume?: AWSVolume;
}
/**
 * A set of acces permissions for AWS resources 
 * @export
 * @interface AWSInfrastructureAccessRole
 */
export interface AWSInfrastructureAccessRole {
    /**
     * Indicates the type of this object. Will be \'AWSInfrastructureAccessRole\' if this is a complete object or \'AWSInfrastructureAccessRoleLink\' if it is just a link. 
     * @type {string}
     * @memberof AWSInfrastructureAccessRole
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof AWSInfrastructureAccessRole
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof AWSInfrastructureAccessRole
     */
    href?: string;
    /**
     * Description of the role. 
     * @type {string}
     * @memberof AWSInfrastructureAccessRole
     */
    description?: string;
    /**
     * Human friendly identifier of the role, for example `Read only`. 
     * @type {string}
     * @memberof AWSInfrastructureAccessRole
     */
    display_name?: string;
    /**
     * 
     * @type {AWSInfrastructureAccessRoleState}
     * @memberof AWSInfrastructureAccessRole
     */
    state?: AWSInfrastructureAccessRoleState;
}
/**
 * Representation of an AWS infrastructure access role grant. 
 * @export
 * @interface AWSInfrastructureAccessRoleGrant
 */
export interface AWSInfrastructureAccessRoleGrant {
    /**
     * Indicates the type of this object. Will be \'AWSInfrastructureAccessRoleGrant\' if this is a complete object or \'AWSInfrastructureAccessRoleGrantLink\' if it is just a link. 
     * @type {string}
     * @memberof AWSInfrastructureAccessRoleGrant
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof AWSInfrastructureAccessRoleGrant
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof AWSInfrastructureAccessRoleGrant
     */
    href?: string;
    /**
     * URL to switch to the role in AWS console. 
     * @type {string}
     * @memberof AWSInfrastructureAccessRoleGrant
     */
    console_url?: string;
    /**
     * 
     * @type {AWSInfrastructureAccessRole}
     * @memberof AWSInfrastructureAccessRoleGrant
     */
    role?: AWSInfrastructureAccessRole;
    /**
     * 
     * @type {AWSInfrastructureAccessRoleGrantState}
     * @memberof AWSInfrastructureAccessRoleGrant
     */
    state?: AWSInfrastructureAccessRoleGrantState;
    /**
     * Description of the state. Will be empty unless state is \'Failed\'. 
     * @type {string}
     * @memberof AWSInfrastructureAccessRoleGrant
     */
    state_description?: string;
    /**
     * The user AWS IAM ARN we want to grant the role. 
     * @type {string}
     * @memberof AWSInfrastructureAccessRoleGrant
     */
    user_arn?: string;
}
/**
 * State of an AWS infrastructure access role grant. 
 * @export
 * @enum {string}
 */
export enum AWSInfrastructureAccessRoleGrantState {
    Deleting = 'deleting',
    Failed = 'failed',
    Pending = 'pending',
    Ready = 'ready',
    Removed = 'removed'
}

/**
 * State of an AWS infrastructure access role. 
 * @export
 * @enum {string}
 */
export enum AWSInfrastructureAccessRoleState {
    Invalid = 'invalid',
    Removed = 'removed',
    Valid = 'valid'
}

/**
 * Holds settings for an AWS storage volume. 
 * @export
 * @interface AWSVolume
 */
export interface AWSVolume {
    /**
     * Volume provisioned IOPS. 
     * @type {number}
     * @memberof AWSVolume
     */
    iops?: number;
    /**
     * Volume size in Gib. 
     * @type {number}
     * @memberof AWSVolume
     */
    size?: number;
    /**
     * Volume Type  Possible values are: \'io1\', \'gp2\', \'st1\', \'sc1\', \'standard\' 
     * @type {string}
     * @memberof AWSVolume
     */
    type?: string;
}
/**
 * Representation of an add-on that can be installed in a cluster. 
 * @export
 * @interface AddOn
 */
export interface AddOn {
    /**
     * Indicates the type of this object. Will be \'AddOn\' if this is a complete object or \'AddOnLink\' if it is just a link. 
     * @type {string}
     * @memberof AddOn
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof AddOn
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof AddOn
     */
    href?: string;
    /**
     * Description of the add-on. 
     * @type {string}
     * @memberof AddOn
     */
    description?: string;
    /**
     * Link to documentation about the add-on. 
     * @type {string}
     * @memberof AddOn
     */
    docs_link?: string;
    /**
     * Indicates if this add-on can be added to clusters. 
     * @type {boolean}
     * @memberof AddOn
     */
    enabled?: boolean;
    /**
     * Indicates if this add-on has external resources associated with it 
     * @type {boolean}
     * @memberof AddOn
     */
    has_external_resources?: boolean;
    /**
     * Indicates if this add-on is hidden. 
     * @type {boolean}
     * @memberof AddOn
     */
    hidden?: boolean;
    /**
     * Base64-encoded icon representing an add-on. The icon should be in PNG format. 
     * @type {string}
     * @memberof AddOn
     */
    icon?: string;
    /**
     * 
     * @type {AddOnInstallMode}
     * @memberof AddOn
     */
    install_mode?: AddOnInstallMode;
    /**
     * Label used to attach to a cluster deployment when add-on is installed. 
     * @type {string}
     * @memberof AddOn
     */
    label?: string;
    /**
     * Name of the add-on. 
     * @type {string}
     * @memberof AddOn
     */
    name?: string;
    /**
     * The name of the operator installed by this add-on. 
     * @type {string}
     * @memberof AddOn
     */
    operator_name?: string;
    /**
     * List of parameters for this add-on. 
     * @type {Array<AddOnParameter>}
     * @memberof AddOn
     */
    parameters?: Array<AddOnParameter>;
    /**
     * List of requirements for this add-on. 
     * @type {Array<AddOnRequirement>}
     * @memberof AddOn
     */
    requirements?: Array<AddOnRequirement>;
    /**
     * Used to determine how many units of quota an add-on consumes per resource name. 
     * @type {number}
     * @memberof AddOn
     */
    resource_cost?: number;
    /**
     * Used to determine from where to reserve quota for this add-on. 
     * @type {string}
     * @memberof AddOn
     */
    resource_name?: string;
    /**
     * List of sub operators for this add-on. 
     * @type {Array<AddOnSubOperator>}
     * @memberof AddOn
     */
    sub_operators?: Array<AddOnSubOperator>;
    /**
     * The namespace in which the addon CRD exists. 
     * @type {string}
     * @memberof AddOn
     */
    target_namespace?: string;
}
/**
 * Representation of an add-on InstallMode field. 
 * @export
 * @enum {string}
 */
export enum AddOnInstallMode {
    AllNamespaces = 'all_namespaces',
    SingleNamespace = 'single_namespace'
}

/**
 * Representation of an add-on installation in a cluster. 
 * @export
 * @interface AddOnInstallation
 */
export interface AddOnInstallation {
    /**
     * Indicates the type of this object. Will be \'AddOnInstallation\' if this is a complete object or \'AddOnInstallationLink\' if it is just a link. 
     * @type {string}
     * @memberof AddOnInstallation
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof AddOnInstallation
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof AddOnInstallation
     */
    href?: string;
    /**
     * 
     * @type {AddOn}
     * @memberof AddOnInstallation
     */
    addon?: AddOn;
    /**
     * 
     * @type {Cluster}
     * @memberof AddOnInstallation
     */
    cluster?: Cluster;
    /**
     * Date and time when the add-on was initially installed in the cluster. 
     * @type {string}
     * @memberof AddOnInstallation
     */
    creation_timestamp?: string;
    /**
     * Version of the operator installed by the add-on. 
     * @type {string}
     * @memberof AddOnInstallation
     */
    operator_version?: string;
    /**
     * List of add-on parameters for this add-on installation. 
     * @type {Array<AddOnInstallationParameter>}
     * @memberof AddOnInstallation
     */
    parameters?: Array<AddOnInstallationParameter>;
    /**
     * 
     * @type {AddOnInstallationState}
     * @memberof AddOnInstallation
     */
    state?: AddOnInstallationState;
    /**
     * Reason for the current State. 
     * @type {string}
     * @memberof AddOnInstallation
     */
    state_description?: string;
    /**
     * Date and time when the add-on installation information was last updated. 
     * @type {string}
     * @memberof AddOnInstallation
     */
    updated_timestamp?: string;
}
/**
 * Representation of an add-on installation parameter. 
 * @export
 * @interface AddOnInstallationParameter
 */
export interface AddOnInstallationParameter {
    /**
     * Indicates the type of this object. Will be \'AddOnInstallationParameter\' if this is a complete object or \'AddOnInstallationParameterLink\' if it is just a link. 
     * @type {string}
     * @memberof AddOnInstallationParameter
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof AddOnInstallationParameter
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof AddOnInstallationParameter
     */
    href?: string;
    /**
     * Value of the parameter. 
     * @type {string}
     * @memberof AddOnInstallationParameter
     */
    value?: string;
}
/**
 * Representation of an add-on installation State field. 
 * @export
 * @enum {string}
 */
export enum AddOnInstallationState {
    Deleting = 'deleting',
    Failed = 'failed',
    Installing = 'installing',
    Pending = 'pending',
    Ready = 'ready'
}

/**
 * Representation of an add-on parameter. 
 * @export
 * @interface AddOnParameter
 */
export interface AddOnParameter {
    /**
     * Indicates the type of this object. Will be \'AddOnParameter\' if this is a complete object or \'AddOnParameterLink\' if it is just a link. 
     * @type {string}
     * @memberof AddOnParameter
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof AddOnParameter
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof AddOnParameter
     */
    href?: string;
    /**
     * 
     * @type {AddOn}
     * @memberof AddOnParameter
     */
    addon?: AddOn;
    /**
     * Indicates the value default for the add-on parameter 
     * @type {string}
     * @memberof AddOnParameter
     */
    default_value?: string;
    /**
     * Description of the add-on parameter. 
     * @type {string}
     * @memberof AddOnParameter
     */
    description?: string;
    /**
     * Indicates if this parameter can be edited after creation. 
     * @type {boolean}
     * @memberof AddOnParameter
     */
    editable?: boolean;
    /**
     * Indicates if this parameter is enabled for the add-on. 
     * @type {boolean}
     * @memberof AddOnParameter
     */
    enabled?: boolean;
    /**
     * Name of the add-on parameter. 
     * @type {string}
     * @memberof AddOnParameter
     */
    name?: string;
    /**
     * Indicates if this parameter is required by the add-on. 
     * @type {boolean}
     * @memberof AddOnParameter
     */
    required?: boolean;
    /**
     * Validation rule for the add-on parameter. 
     * @type {string}
     * @memberof AddOnParameter
     */
    validation?: string;
    /**
     * Type of value of the add-on parameter. 
     * @type {string}
     * @memberof AddOnParameter
     */
    value_type?: string;
}
/**
 * Representation of an add-on requirement. 
 * @export
 * @interface AddOnRequirement
 */
export interface AddOnRequirement {
    /**
     * ID of the add-on requirement. 
     * @type {string}
     * @memberof AddOnRequirement
     */
    id?: string;
    /**
     * Data for the add-on requirement. 
     * @type {{ [key: string]: object; }}
     * @memberof AddOnRequirement
     */
    data?: { [key: string]: object; };
    /**
     * Indicates if this requirement is enabled for the add-on. 
     * @type {boolean}
     * @memberof AddOnRequirement
     */
    enabled?: boolean;
    /**
     * Type of resource of the add-on requirement. 
     * @type {string}
     * @memberof AddOnRequirement
     */
    resource?: string;
}
/**
 * Representation of an add-on sub operator. A sub operator is an operator who\'s life cycle is controlled by the add-on umbrella operator.  
 * @export
 * @interface AddOnSubOperator
 */
export interface AddOnSubOperator {
    /**
     * Indicates if the sub operator is enabled for the add-on 
     * @type {boolean}
     * @memberof AddOnSubOperator
     */
    enabled?: boolean;
    /**
     * Name of the add-on sub operator 
     * @type {string}
     * @memberof AddOnSubOperator
     */
    operator_name?: string;
    /**
     * Namespace of the add-on sub operator 
     * @type {string}
     * @memberof AddOnSubOperator
     */
    operator_namespace?: string;
}
/**
 * Targets workloads to an addon cluster
 * @export
 * @interface AddonClusterTarget
 */
export interface AddonClusterTarget {
    /**
     * 
     * @type {string}
     * @memberof AddonClusterTarget
     */
    kind: string;
    /**
     * 
     * @type {string}
     * @memberof AddonClusterTarget
     */
    group?: string;
}
/**
 * A addon parameter
 * @export
 * @interface AddonParameter
 */
export interface AddonParameter {
    /**
     * 
     * @type {string}
     * @memberof AddonParameter
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AddonParameter
     */
    value?: string;
}
/**
 * Temporary administrator credentials generated during the installation of the cluster. 
 * @export
 * @interface AdminCredentials
 */
export interface AdminCredentials {
    /**
     * Cluster administrator password. 
     * @type {string}
     * @memberof AdminCredentials
     */
    password?: string;
    /**
     * Cluster administrator user name. 
     * @type {string}
     * @memberof AdminCredentials
     */
    user?: string;
}
/**
 * Provides information about a single alert firing on the cluster. 
 * @export
 * @interface AlertInfo
 */
export interface AlertInfo {
    /**
     * The alert name. Multiple alerts with same name are possible. 
     * @type {string}
     * @memberof AlertInfo
     */
    name?: string;
    /**
     * 
     * @type {AlertSeverity}
     * @memberof AlertInfo
     */
    severity?: AlertSeverity;
}
/**
 * Severity of a cluster alert received via telemetry. 
 * @export
 * @enum {string}
 */
export enum AlertSeverity {
    Critical = 'critical',
    None = 'none',
    Warning = 'warning'
}

/**
 * Provides information about the alerts firing on the cluster. 
 * @export
 * @interface AlertsInfo
 */
export interface AlertsInfo {
    /**
     * 
     * @type {Array<AlertInfo>}
     * @memberof AlertsInfo
     */
    alerts?: Array<AlertInfo>;
}
/**
 * Billing model for cluster resources. 
 * @export
 * @enum {string}
 */
export enum BillingModel {
    Marketplace = 'marketplace',
    Standard = 'standard'
}

/**
 * 
 * @export
 * @interface CCS
 */
export interface CCS {
    /**
     * Indicates the type of this object. Will be \'CCS\' if this is a complete object or \'CCSLink\' if it is just a link. 
     * @type {string}
     * @memberof CCS
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof CCS
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof CCS
     */
    href?: string;
    /**
     * Indicates if cloud permissions checks are disabled, when attempting installation of the cluster. 
     * @type {boolean}
     * @memberof CCS
     */
    disable_scp_checks?: boolean;
    /**
     * Indicates if Customer Cloud Subscription is enabled on the cluster. 
     * @type {boolean}
     * @memberof CCS
     */
    enabled?: boolean;
}
/**
 * Representation of information from telemetry about a the CPU capacity by node role and OS. 
 * @export
 * @interface CPUTotalNodeRoleOSMetricNode
 */
export interface CPUTotalNodeRoleOSMetricNode {
    /**
     * The total CPU capacity of nodes with this set of roles and operating system. 
     * @type {number}
     * @memberof CPUTotalNodeRoleOSMetricNode
     */
    cpu_total?: number;
    /**
     * Representation of the node role for a cluster. 
     * @type {Array<string>}
     * @memberof CPUTotalNodeRoleOSMetricNode
     */
    node_roles?: Array<string>;
    /**
     * The operating system. 
     * @type {string}
     * @memberof CPUTotalNodeRoleOSMetricNode
     */
    operating_system?: string;
    /**
     * 
     * @type {string}
     * @memberof CPUTotalNodeRoleOSMetricNode
     */
    time?: string;
}
/**
 * Representation of information from telemetry about the CPU capacity by node role and OS of a cluster. 
 * @export
 * @interface CPUTotalsNodeRoleOSMetricNode
 */
export interface CPUTotalsNodeRoleOSMetricNode {
    /**
     * 
     * @type {Array<CPUTotalNodeRoleOSMetricNode>}
     * @memberof CPUTotalsNodeRoleOSMetricNode
     */
    cpu_totals?: Array<CPUTotalNodeRoleOSMetricNode>;
}
/**
 * Cloud provider.
 * @export
 * @interface CloudProvider
 */
export interface CloudProvider {
    /**
     * Indicates the type of this object. Will be \'CloudProvider\' link.
     * @type {string}
     * @memberof CloudProvider
     */
    kind?: string;
    /**
     * Unique identifier of the object.
     * @type {string}
     * @memberof CloudProvider
     */
    id?: string;
    /**
     * Name of the cloud provider for display purposes.
     * @type {string}
     * @memberof CloudProvider
     */
    display_name?: string;
    /**
     * Human friendly identifier of the cloud provider, for example `aws`.
     * @type {string}
     * @memberof CloudProvider
     */
    name?: string;
    /**
     * Whether the cloud provider is enabled for deploying an OSD cluster.
     * @type {boolean}
     * @memberof CloudProvider
     */
    enabled: boolean;
}
/**
 * Cloud provider. 
 * @export
 * @interface CloudProvider1
 */
export interface CloudProvider1 {
    /**
     * Indicates the type of this object. Will be \'CloudProvider\' if this is a complete object or \'CloudProviderLink\' if it is just a link. 
     * @type {string}
     * @memberof CloudProvider1
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof CloudProvider1
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof CloudProvider1
     */
    href?: string;
    /**
     * Name of the cloud provider for display purposes. It can contain any characters, including spaces. 
     * @type {string}
     * @memberof CloudProvider1
     */
    display_name?: string;
    /**
     * Human friendly identifier of the cloud provider, for example `aws`. 
     * @type {string}
     * @memberof CloudProvider1
     */
    name?: string;
}
/**
 * Targets workloads to a cloud provider
 * @export
 * @interface CloudProviderClusterTarget
 */
export interface CloudProviderClusterTarget {
    /**
     * 
     * @type {string}
     * @memberof CloudProviderClusterTarget
     */
    kind: string;
    /**
     * 
     * @type {string}
     * @memberof CloudProviderClusterTarget
     */
    cloud_provider?: string;
    /**
     * 
     * @type {string}
     * @memberof CloudProviderClusterTarget
     */
    region?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CloudProviderClusterTarget
     */
    multi_az?: boolean;
}
/**
 * 
 * @export
 * @interface CloudProviderList
 */
export interface CloudProviderList {
    /**
     * 
     * @type {string}
     * @memberof CloudProviderList
     */
    kind: string;
    /**
     * 
     * @type {number}
     * @memberof CloudProviderList
     */
    page: number;
    /**
     * 
     * @type {number}
     * @memberof CloudProviderList
     */
    size: number;
    /**
     * 
     * @type {number}
     * @memberof CloudProviderList
     */
    total: number;
    /**
     * 
     * @type {Array<CloudProvider>}
     * @memberof CloudProviderList
     */
    items: Array<CloudProvider>;
}
/**
 * 
 * @export
 * @interface CloudProviderListAllOf
 */
export interface CloudProviderListAllOf {
    /**
     * 
     * @type {Array<CloudProvider>}
     * @memberof CloudProviderListAllOf
     */
    items?: Array<CloudProvider>;
}
/**
 * Description of a region of a cloud provider.
 * @export
 * @interface CloudRegion
 */
export interface CloudRegion {
    /**
     * Indicates the type of this object. Will be \'CloudRegion\'.
     * @type {string}
     * @memberof CloudRegion
     */
    kind?: string;
    /**
     * Unique identifier of the object.
     * @type {string}
     * @memberof CloudRegion
     */
    id?: string;
    /**
     * Name of the region for display purposes, for example `N. Virginia`.
     * @type {string}
     * @memberof CloudRegion
     */
    display_name?: string;
    /**
     * Whether the region is enabled for deploying an OSD cluster.
     * @type {boolean}
     * @memberof CloudRegion
     */
    enabled: boolean;
}
/**
 * Description of a region of a cloud provider. 
 * @export
 * @interface CloudRegion1
 */
export interface CloudRegion1 {
    /**
     * Indicates the type of this object. Will be \'CloudRegion\' if this is a complete object or \'CloudRegionLink\' if it is just a link. 
     * @type {string}
     * @memberof CloudRegion1
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof CloudRegion1
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof CloudRegion1
     */
    href?: string;
    /**
     * 
     * @type {CloudProvider1}
     * @memberof CloudRegion1
     */
    cloud_provider?: CloudProvider1;
    /**
     * Name of the region for display purposes, for example `N. Virginia`. 
     * @type {string}
     * @memberof CloudRegion1
     */
    display_name?: string;
    /**
     * Whether the region is enabled for deploying an OSD cluster. 
     * @type {boolean}
     * @memberof CloudRegion1
     */
    enabled?: boolean;
    /**
     * Human friendly identifier of the region, for example `us-east-1`.  NOTE: Currently for all cloud providers and all regions `id` and `name` have exactly the same values. 
     * @type {string}
     * @memberof CloudRegion1
     */
    name?: string;
    /**
     * Whether the region supports multiple availability zones. 
     * @type {boolean}
     * @memberof CloudRegion1
     */
    supports_multi_az?: boolean;
}
/**
 * 
 * @export
 * @interface CloudRegionList
 */
export interface CloudRegionList {
    /**
     * 
     * @type {string}
     * @memberof CloudRegionList
     */
    kind: string;
    /**
     * 
     * @type {number}
     * @memberof CloudRegionList
     */
    page: number;
    /**
     * 
     * @type {number}
     * @memberof CloudRegionList
     */
    size: number;
    /**
     * 
     * @type {number}
     * @memberof CloudRegionList
     */
    total: number;
    /**
     * 
     * @type {Array<CloudRegion>}
     * @memberof CloudRegionList
     */
    items: Array<CloudRegion>;
}
/**
 * 
 * @export
 * @interface CloudRegionListAllOf
 */
export interface CloudRegionListAllOf {
    /**
     * 
     * @type {Array<CloudRegion>}
     * @memberof CloudRegionListAllOf
     */
    items?: Array<CloudRegion>;
}
/**
 * Definition of an _OpenShift_ cluster.  The `cloud_provider` attribute is a reference to the cloud provider. When a cluster is retrieved it will be a link to the cloud provider, containing only the kind, id and href attributes:   ``` {   \"cloud_provider\": {     \"kind\": \"CloudProviderLink\",     \"id\": \"123\",     \"href\": \"/api/clusters_mgmt/v1/cloud_providers/123\"   } } ```  When a cluster is created this is optional, and if used it should contain the identifier of the cloud provider to use:   ``` {   \"cloud_provider\": {     \"id\": \"123\",   } } ```  If not included, then the cluster will be created using the default cloud provider, which is currently Amazon Web Services.  The region attribute is mandatory when a cluster is created.  The `aws.access_key_id`, `aws.secret_access_key` and `dns.base_domain` attributes are mandatory when creation a cluster with your own Amazon Web Services account. 
 * @export
 * @interface Cluster
 */
export interface Cluster {
    /**
     * Indicates the type of this object. Will be \'Cluster\' if this is a complete object or \'ClusterLink\' if it is just a link. 
     * @type {string}
     * @memberof Cluster
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof Cluster
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof Cluster
     */
    href?: string;
    /**
     * 
     * @type {ClusterAPI}
     * @memberof Cluster
     */
    api?: ClusterAPI;
    /**
     * 
     * @type {AWS}
     * @memberof Cluster
     */
    aws?: AWS;
    /**
     * List of AWS infrastructure access role grants on this cluster. 
     * @type {Array<AWSInfrastructureAccessRoleGrant>}
     * @memberof Cluster
     */
    aws_infrastructure_access_role_grants?: Array<AWSInfrastructureAccessRoleGrant>;
    /**
     * 
     * @type {CCS}
     * @memberof Cluster
     */
    ccs?: CCS;
    /**
     * 
     * @type {DNS}
     * @memberof Cluster
     */
    dns?: DNS;
    /**
     * 
     * @type {GCP}
     * @memberof Cluster
     */
    gcp?: GCP;
    /**
     * List of add-ons on this cluster. 
     * @type {Array<AddOnInstallation>}
     * @memberof Cluster
     */
    addons?: Array<AddOnInstallation>;
    /**
     * 
     * @type {BillingModel}
     * @memberof Cluster
     */
    billing_model?: BillingModel;
    /**
     * 
     * @type {CloudProvider1}
     * @memberof Cluster
     */
    cloud_provider?: CloudProvider1;
    /**
     * 
     * @type {ClusterConsole}
     * @memberof Cluster
     */
    console?: ClusterConsole;
    /**
     * Date and time when the cluster was initially created, using the format defined in https://www.ietf.org/rfc/rfc3339.txt[RC3339]. 
     * @type {string}
     * @memberof Cluster
     */
    creation_timestamp?: string;
    /**
     * Name of the cluster for display purposes. It can contain any characters, including spaces. 
     * @type {string}
     * @memberof Cluster
     */
    display_name?: string;
    /**
     * Indicates whether that etcd is encrypted or not. This is set only during cluster creation. 
     * @type {boolean}
     * @memberof Cluster
     */
    etcd_encryption?: boolean;
    /**
     * Date and time when the cluster will be automatically deleted, using the format defined in https://www.ietf.org/rfc/rfc3339.txt[RFC3339]. If no timestamp is provided, the cluster will never expire.  This option is unsupported. 
     * @type {string}
     * @memberof Cluster
     */
    expiration_timestamp?: string;
    /**
     * External identifier of the cluster, generated by the installer. 
     * @type {string}
     * @memberof Cluster
     */
    external_id?: string;
    /**
     * 
     * @type {ExternalConfiguration}
     * @memberof Cluster
     */
    external_configuration?: ExternalConfiguration;
    /**
     * 
     * @type {Flavour}
     * @memberof Cluster
     */
    flavour?: Flavour;
    /**
     * Link to the collection of groups of user of the cluster. 
     * @type {Array<Group>}
     * @memberof Cluster
     */
    groups?: Array<Group>;
    /**
     * 
     * @type {ClusterHealthState}
     * @memberof Cluster
     */
    health_state?: ClusterHealthState;
    /**
     * Link to the collection of identity providers of the cluster. 
     * @type {Array<IdentityProvider>}
     * @memberof Cluster
     */
    identity_providers?: Array<IdentityProvider>;
    /**
     * List of ingresses on this cluster. 
     * @type {Array<Ingress>}
     * @memberof Cluster
     */
    ingresses?: Array<Ingress>;
    /**
     * Load Balancer quota to be assigned to the cluster. 
     * @type {number}
     * @memberof Cluster
     */
    load_balancer_quota?: number;
    /**
     * List of machine pools on this cluster. 
     * @type {Array<MachinePool>}
     * @memberof Cluster
     */
    machine_pools?: Array<MachinePool>;
    /**
     * Flag indicating if the cluster is managed (by Red Hat) or self-managed by the user. 
     * @type {boolean}
     * @memberof Cluster
     */
    managed?: boolean;
    /**
     * 
     * @type {ClusterMetrics}
     * @memberof Cluster
     */
    metrics?: ClusterMetrics;
    /**
     * Flag indicating if the cluster should be created with nodes in different availability zones or all the nodes in a single one randomly selected. 
     * @type {boolean}
     * @memberof Cluster
     */
    multi_az?: boolean;
    /**
     * Name of the cluster. This name is assigned by the user when the cluster is created. 
     * @type {string}
     * @memberof Cluster
     */
    name?: string;
    /**
     * 
     * @type {Network}
     * @memberof Cluster
     */
    network?: Network;
    /**
     * 
     * @type {Value}
     * @memberof Cluster
     */
    node_drain_grace_period?: Value;
    /**
     * 
     * @type {ClusterNodes}
     * @memberof Cluster
     */
    nodes?: ClusterNodes;
    /**
     * Version of _OpenShift_ installed in the cluster, for example `4.0.0-0.2`.  When retrieving a cluster this will always be reported.  When provisioning a cluster this will be ignored, as the version to deploy will be determined internally. 
     * @type {string}
     * @memberof Cluster
     */
    openshift_version?: string;
    /**
     * 
     * @type {Product}
     * @memberof Cluster
     */
    product?: Product;
    /**
     * User defined properties for tagging and querying. 
     * @type {{ [key: string]: string; }}
     * @memberof Cluster
     */
    properties?: { [key: string]: string; };
    /**
     * 
     * @type {ProvisionShard}
     * @memberof Cluster
     */
    provision_shard?: ProvisionShard;
    /**
     * 
     * @type {CloudRegion1}
     * @memberof Cluster
     */
    region?: CloudRegion1;
    /**
     * 
     * @type {ClusterState}
     * @memberof Cluster
     */
    state?: ClusterState;
    /**
     * 
     * @type {ClusterStatus}
     * @memberof Cluster
     */
    status?: ClusterStatus;
    /**
     * 
     * @type {Value}
     * @memberof Cluster
     */
    storage_quota?: Value;
    /**
     * 
     * @type {Subscription}
     * @memberof Cluster
     */
    subscription?: Subscription;
    /**
     * Channel group to be used for upgrading the cluster. Valid values: stable (default), fast, candidate, nightly. 
     * @type {string}
     * @memberof Cluster
     */
    upgrade_channel_group?: string;
    /**
     * 
     * @type {Version}
     * @memberof Cluster
     */
    version?: Version;
}
/**
 * Information about the API of a cluster. 
 * @export
 * @interface ClusterAPI
 */
export interface ClusterAPI {
    /**
     * The URL of the API server of the cluster. 
     * @type {string}
     * @memberof ClusterAPI
     */
    url?: string;
    /**
     * 
     * @type {ListeningMethod}
     * @memberof ClusterAPI
     */
    listening?: ListeningMethod;
}
/**
 * Information about the console of a cluster. 
 * @export
 * @interface ClusterConsole
 */
export interface ClusterConsole {
    /**
     * The URL of the console of the cluster. 
     * @type {string}
     * @memberof ClusterConsole
     */
    url?: string;
}
/**
 * Credentials of the a cluster. 
 * @export
 * @interface ClusterCredentials
 */
export interface ClusterCredentials {
    /**
     * Indicates the type of this object. Will be \'ClusterCredentials\' if this is a complete object or \'ClusterCredentialsLink\' if it is just a link. 
     * @type {string}
     * @memberof ClusterCredentials
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof ClusterCredentials
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof ClusterCredentials
     */
    href?: string;
    /**
     * 
     * @type {SSHCredentials}
     * @memberof ClusterCredentials
     */
    ssh?: SSHCredentials;
    /**
     * 
     * @type {AdminCredentials}
     * @memberof ClusterCredentials
     */
    admin?: AdminCredentials;
    /**
     * Administrator _kubeconfig_ file for the cluster. 
     * @type {string}
     * @memberof ClusterCredentials
     */
    kubeconfig?: string;
}
/**
 * ClusterHealthState indicates the health of a cluster. 
 * @export
 * @enum {string}
 */
export enum ClusterHealthState {
    Healthy = 'healthy',
    Unhealthy = 'unhealthy',
    Unknown = 'unknown'
}

/**
 * Metric describing the total and used amount of some resource (like RAM, CPU and storage) in a cluster. 
 * @export
 * @interface ClusterMetric
 */
export interface ClusterMetric {
    /**
     * 
     * @type {Value}
     * @memberof ClusterMetric
     */
    total?: Value;
    /**
     * Collection timestamp of the metric. 
     * @type {string}
     * @memberof ClusterMetric
     */
    updated_timestamp?: string;
    /**
     * 
     * @type {Value}
     * @memberof ClusterMetric
     */
    used?: Value;
}
/**
 * Cluster metrics received via telemetry. 
 * @export
 * @interface ClusterMetrics
 */
export interface ClusterMetrics {
    /**
     * 
     * @type {ClusterMetric}
     * @memberof ClusterMetrics
     */
    cpu?: ClusterMetric;
    /**
     * 
     * @type {ClusterMetric}
     * @memberof ClusterMetrics
     */
    compute_nodes_cpu?: ClusterMetric;
    /**
     * 
     * @type {ClusterMetric}
     * @memberof ClusterMetrics
     */
    compute_nodes_memory?: ClusterMetric;
    /**
     * 
     * @type {ClusterMetric}
     * @memberof ClusterMetrics
     */
    compute_nodes_sockets?: ClusterMetric;
    /**
     * CriticalAlertsFiring contains information about critical alerts firing. 
     * @type {number}
     * @memberof ClusterMetrics
     */
    critical_alerts_firing?: number;
    /**
     * 
     * @type {ClusterMetric}
     * @memberof ClusterMetrics
     */
    memory?: ClusterMetric;
    /**
     * 
     * @type {ClusterNodes}
     * @memberof ClusterMetrics
     */
    nodes?: ClusterNodes;
    /**
     * OperatorsConditionFailing contains information about operator in failing condition in the cluster. 
     * @type {number}
     * @memberof ClusterMetrics
     */
    operators_condition_failing?: number;
    /**
     * 
     * @type {ClusterMetric}
     * @memberof ClusterMetrics
     */
    sockets?: ClusterMetric;
    /**
     * 
     * @type {ClusterMetric}
     * @memberof ClusterMetrics
     */
    storage?: ClusterMetric;
}
/**
 * Counts of different classes of nodes inside a cluster. 
 * @export
 * @interface ClusterNodes
 */
export interface ClusterNodes {
    /**
     * 
     * @type {MachinePoolAutoscaling}
     * @memberof ClusterNodes
     */
    autoscale_compute?: MachinePoolAutoscaling;
    /**
     * The availability zones upon which the nodes are created. 
     * @type {Array<string>}
     * @memberof ClusterNodes
     */
    availability_zones?: Array<string>;
    /**
     * Number of compute nodes of the cluster. Compute and AutoscaleCompute cannot be used together.     
     * @type {number}
     * @memberof ClusterNodes
     */
    compute?: number;
    /**
     * The labels set on the \"default\" compute machine pool. 
     * @type {{ [key: string]: string; }}
     * @memberof ClusterNodes
     */
    compute_labels?: { [key: string]: string; };
    /**
     * 
     * @type {MachineType}
     * @memberof ClusterNodes
     */
    compute_machine_type?: MachineType;
    /**
     * Number of infrastructure nodes of the cluster. 
     * @type {number}
     * @memberof ClusterNodes
     */
    infra?: number;
    /**
     * Number of master nodes of the cluster. 
     * @type {number}
     * @memberof ClusterNodes
     */
    master?: number;
    /**
     * Total number of nodes of the cluster. 
     * @type {number}
     * @memberof ClusterNodes
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface ClusterOperatorInfo
 */
export interface ClusterOperatorInfo {
    /**
     * 
     * @type {ClusterOperatorState}
     * @memberof ClusterOperatorInfo
     */
    condition?: ClusterOperatorState;
    /**
     * Name of the operator. 
     * @type {string}
     * @memberof ClusterOperatorInfo
     */
    name?: string;
    /**
     * Extra detail on condition, if available.  Empty string if unknown. 
     * @type {string}
     * @memberof ClusterOperatorInfo
     */
    reason?: string;
    /**
     * Time when the sample was obtained, in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) format. 
     * @type {string}
     * @memberof ClusterOperatorInfo
     */
    time?: string;
    /**
     * Current version of the operator.  Empty string if unknown. 
     * @type {string}
     * @memberof ClusterOperatorInfo
     */
    version?: string;
}
/**
 * Overall state of a cluster operator. 
 * @export
 * @enum {string}
 */
export enum ClusterOperatorState {
    Available = 'available',
    Degraded = 'degraded',
    Failing = 'failing',
    Upgrading = 'upgrading'
}

/**
 * Provides detailed information about the operators installed on the cluster. 
 * @export
 * @interface ClusterOperatorsInfo
 */
export interface ClusterOperatorsInfo {
    /**
     * 
     * @type {Array<ClusterOperatorInfo>}
     * @memberof ClusterOperatorsInfo
     */
    operators?: Array<ClusterOperatorInfo>;
}
/**
 * Registration of a new cluster to the service. 
 * @export
 * @interface ClusterRegistration
 */
export interface ClusterRegistration {
    /**
     * Identifier of the cluster generated by the installer.  For example, to register a cluster that has been provisioned outside of this service, send a a request like this:   ``` POST /api/clusters_mgmt/v1/register_cluster HTTP/1.1 ```  With a request body like this:   ``` {   \"external_id\": \"d656aecf-11a6-4782-ad86-8f72638449ba\" } ``` 
     * @type {string}
     * @memberof ClusterRegistration
     */
    external_id?: string;
    /**
     * Optional Organization identifier of the cluster generated by the account manager. 
     * @type {string}
     * @memberof ClusterRegistration
     */
    organization_id?: string;
    /**
     * Subscription identifier of the cluster generated by the account manager. 
     * @type {string}
     * @memberof ClusterRegistration
     */
    subscription_id?: string;
}
/**
 * Overall state of a cluster. 
 * @export
 * @enum {string}
 */
export enum ClusterState {
    Error = 'error',
    Installing = 'installing',
    Pending = 'pending',
    Ready = 'ready',
    Uninstalling = 'uninstalling',
    Unknown = 'unknown'
}

/**
 * Detailed status of a cluster. 
 * @export
 * @interface ClusterStatus
 */
export interface ClusterStatus {
    /**
     * Indicates the type of this object. Will be \'ClusterStatus\' if this is a complete object or \'ClusterStatusLink\' if it is just a link. 
     * @type {string}
     * @memberof ClusterStatus
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof ClusterStatus
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof ClusterStatus
     */
    href?: string;
    /**
     * DNSReady from Provisioner 
     * @type {boolean}
     * @memberof ClusterStatus
     */
    dns_ready?: boolean;
    /**
     * Detailed description of the cluster status. 
     * @type {string}
     * @memberof ClusterStatus
     */
    description?: string;
    /**
     * Provisioning Error Code 
     * @type {string}
     * @memberof ClusterStatus
     */
    provision_error_code?: string;
    /**
     * Provisioning Error Message 
     * @type {string}
     * @memberof ClusterStatus
     */
    provision_error_message?: string;
    /**
     * 
     * @type {ClusterState}
     * @memberof ClusterStatus
     */
    state?: ClusterState;
}
/**
 * @type ClusterTarget
 * @export
 */
export type ClusterTarget = AddonClusterTarget | CloudProviderClusterTarget;

/**
 * A connector holds the configuration to connect a Kafka topic to another system.
 * @export
 * @interface Connector
 */
export interface Connector {
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    href?: string;
    /**
     * 
     * @type {ConnectorAllOfMetadata}
     * @memberof Connector
     */
    metadata?: ConnectorAllOfMetadata;
    /**
     * 
     * @type {ClusterTarget}
     * @memberof Connector
     */
    deployment_location?: ClusterTarget;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    connector_type_id?: string;
    /**
     * 
     * @type {object}
     * @memberof Connector
     */
    connector_spec?: object;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface ConnectorAllOf
 */
export interface ConnectorAllOf {
    /**
     * 
     * @type {ConnectorAllOfMetadata}
     * @memberof ConnectorAllOf
     */
    metadata?: ConnectorAllOfMetadata;
    /**
     * 
     * @type {ClusterTarget}
     * @memberof ConnectorAllOf
     */
    deployment_location?: ClusterTarget;
    /**
     * 
     * @type {string}
     * @memberof ConnectorAllOf
     */
    connector_type_id?: string;
    /**
     * 
     * @type {object}
     * @memberof ConnectorAllOf
     */
    connector_spec?: object;
    /**
     * 
     * @type {string}
     * @memberof ConnectorAllOf
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface ConnectorAllOfMetadata
 */
export interface ConnectorAllOfMetadata {
    /**
     * 
     * @type {string}
     * @memberof ConnectorAllOfMetadata
     */
    kafka_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorAllOfMetadata
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorAllOfMetadata
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorAllOfMetadata
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorAllOfMetadata
     */
    updated_at?: string;
    /**
     * 
     * @type {number}
     * @memberof ConnectorAllOfMetadata
     */
    resource_version?: number;
}
/**
 * Schema for the request to update a data plane cluster\'s status
 * @export
 * @interface ConnectorCluster
 */
export interface ConnectorCluster {
    /**
     * 
     * @type {string}
     * @memberof ConnectorCluster
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorCluster
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorCluster
     */
    href?: string;
    /**
     * 
     * @type {ConnectorClusterAllOfMetadata}
     * @memberof ConnectorCluster
     */
    metadata?: ConnectorClusterAllOfMetadata;
    /**
     * 
     * @type {string}
     * @memberof ConnectorCluster
     */
    service_account?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorCluster
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface ConnectorClusterAllOf
 */
export interface ConnectorClusterAllOf {
    /**
     * 
     * @type {ConnectorClusterAllOfMetadata}
     * @memberof ConnectorClusterAllOf
     */
    metadata?: ConnectorClusterAllOfMetadata;
    /**
     * 
     * @type {string}
     * @memberof ConnectorClusterAllOf
     */
    service_account?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorClusterAllOf
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface ConnectorClusterAllOfMetadata
 */
export interface ConnectorClusterAllOfMetadata {
    /**
     * 
     * @type {string}
     * @memberof ConnectorClusterAllOfMetadata
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorClusterAllOfMetadata
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorClusterAllOfMetadata
     */
    group?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorClusterAllOfMetadata
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorClusterAllOfMetadata
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface ConnectorClusterList
 */
export interface ConnectorClusterList {
    /**
     * 
     * @type {string}
     * @memberof ConnectorClusterList
     */
    kind: string;
    /**
     * 
     * @type {number}
     * @memberof ConnectorClusterList
     */
    page: number;
    /**
     * 
     * @type {number}
     * @memberof ConnectorClusterList
     */
    size: number;
    /**
     * 
     * @type {number}
     * @memberof ConnectorClusterList
     */
    total: number;
    /**
     * 
     * @type {Array<ConnectorCluster>}
     * @memberof ConnectorClusterList
     */
    items: Array<ConnectorCluster>;
}
/**
 * 
 * @export
 * @interface ConnectorClusterListAllOf
 */
export interface ConnectorClusterListAllOf {
    /**
     * 
     * @type {Array<ConnectorCluster>}
     * @memberof ConnectorClusterListAllOf
     */
    items?: Array<ConnectorCluster>;
}
/**
 * Schema for the request to update a data plane cluster\'s status
 * @export
 * @interface ConnectorClusterUpdateStatus
 */
export interface ConnectorClusterUpdateStatus {
    /**
     * 
     * @type {string}
     * @memberof ConnectorClusterUpdateStatus
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface ConnectorList
 */
export interface ConnectorList {
    /**
     * 
     * @type {string}
     * @memberof ConnectorList
     */
    kind: string;
    /**
     * 
     * @type {number}
     * @memberof ConnectorList
     */
    page: number;
    /**
     * 
     * @type {number}
     * @memberof ConnectorList
     */
    size: number;
    /**
     * 
     * @type {number}
     * @memberof ConnectorList
     */
    total: number;
    /**
     * 
     * @type {Array<Connector>}
     * @memberof ConnectorList
     */
    items: Array<Connector>;
}
/**
 * 
 * @export
 * @interface ConnectorListAllOf
 */
export interface ConnectorListAllOf {
    /**
     * 
     * @type {Array<Connector>}
     * @memberof ConnectorListAllOf
     */
    items?: Array<Connector>;
}
/**
 * Represents a connector type supported by the API
 * @export
 * @interface ConnectorType
 */
export interface ConnectorType {
    /**
     * 
     * @type {string}
     * @memberof ConnectorType
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorType
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorType
     */
    href?: string;
    /**
     * Name of the connector type.
     * @type {string}
     * @memberof ConnectorType
     */
    name: string;
    /**
     * Version of the connector type.
     * @type {string}
     * @memberof ConnectorType
     */
    version: string;
    /**
     * A description of the connector.
     * @type {string}
     * @memberof ConnectorType
     */
    description?: string;
    /**
     * A json schema that can be used to validate a connectors connector_spec field.
     * @type {object}
     * @memberof ConnectorType
     */
    json_schema?: object;
}
/**
 * 
 * @export
 * @interface ConnectorTypeAllOf
 */
export interface ConnectorTypeAllOf {
    /**
     * Name of the connector type.
     * @type {string}
     * @memberof ConnectorTypeAllOf
     */
    name?: string;
    /**
     * Version of the connector type.
     * @type {string}
     * @memberof ConnectorTypeAllOf
     */
    version?: string;
    /**
     * A description of the connector.
     * @type {string}
     * @memberof ConnectorTypeAllOf
     */
    description?: string;
    /**
     * A json schema that can be used to validate a connectors connector_spec field.
     * @type {object}
     * @memberof ConnectorTypeAllOf
     */
    json_schema?: object;
}
/**
 * 
 * @export
 * @interface ConnectorTypeList
 */
export interface ConnectorTypeList {
    /**
     * 
     * @type {string}
     * @memberof ConnectorTypeList
     */
    kind: string;
    /**
     * 
     * @type {number}
     * @memberof ConnectorTypeList
     */
    page: number;
    /**
     * 
     * @type {number}
     * @memberof ConnectorTypeList
     */
    size: number;
    /**
     * 
     * @type {number}
     * @memberof ConnectorTypeList
     */
    total: number;
    /**
     * 
     * @type {Array<ConnectorType>}
     * @memberof ConnectorTypeList
     */
    items: Array<ConnectorType>;
}
/**
 * 
 * @export
 * @interface ConnectorTypeListAllOf
 */
export interface ConnectorTypeListAllOf {
    /**
     * 
     * @type {Array<ConnectorType>}
     * @memberof ConnectorTypeListAllOf
     */
    items?: Array<ConnectorType>;
}
/**
 * Schema for the request to update a data plane cluster\'s status
 * @export
 * @interface ConnectorUpdateStatus
 */
export interface ConnectorUpdateStatus {
    /**
     * 
     * @type {string}
     * @memberof ConnectorUpdateStatus
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface ConnectorWatchEvent
 */
export interface ConnectorWatchEvent {
    /**
     * 
     * @type {string}
     * @memberof ConnectorWatchEvent
     */
    type: string;
    /**
     * 
     * @type {Error}
     * @memberof ConnectorWatchEvent
     */
    error?: Error;
    /**
     * 
     * @type {Connector}
     * @memberof ConnectorWatchEvent
     */
    object?: Connector;
}
/**
 * 
 * @export
 * @interface ConnectorWatchEventAllOf
 */
export interface ConnectorWatchEventAllOf {
    /**
     * 
     * @type {Connector}
     * @memberof ConnectorWatchEventAllOf
     */
    object?: Connector;
}
/**
 * DNS settings of the cluster. 
 * @export
 * @interface DNS
 */
export interface DNS {
    /**
     * Base DNS domain of the cluster.  During the installation of the cluster it is necessary to create multiple DNS records. They will be created as sub-domains of this domain. For example, if the name of the cluster is `mycluster` and the base domain is `example.com` then the following DNS records will be created:  ``` mycluster-api.example.com mycluster-etcd-0.example.com mycluster-etcd-1.example.com mycluster-etcd-3.example.com ```  The exact number, type and names of the created DNS record depends on the characteristics of the cluster, and may be different for different versions of _OpenShift_. Please don\'t rely on them. For example, to find what is the URL of the Kubernetes API server of the cluster don\'t assume that it will be `mycluster-api.example.com`. Instead of that use this API to retrieve the description of the cluster, and get it from the `api.url` attribute. For example, if the identifier of the cluster is `123` send a request like this:   ``` GET /api/clusters_mgmt/v1/clusters/123 HTTP/1.1 ```  That will return a response like this, including the `api.url` attribute:   ``` {     \"kind\": \"Cluster\",     \"id\": \"123\",     \"href\": \"/api/clusters_mgmt/v1/clusters/123\",         \"api\": {         \"url\": \"https://mycluster-api.example.com:6443\"     },     ... } ```  When the cluster is created in Amazon Web Services it is necessary to create this base DNS domain in advance, using AWS Route53 (https://console.aws.amazon.com/route53). 
     * @type {string}
     * @memberof DNS
     */
    base_domain?: string;
}
/**
 * Collection of metrics intended to render a graphical dashboard. 
 * @export
 * @interface Dashboard
 */
export interface Dashboard {
    /**
     * Indicates the type of this object. Will be \'Dashboard\' if this is a complete object or \'DashboardLink\' if it is just a link. 
     * @type {string}
     * @memberof Dashboard
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof Dashboard
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof Dashboard
     */
    href?: string;
    /**
     * Metrics included in the dashboard. 
     * @type {Array<Metric>}
     * @memberof Dashboard
     */
    metrics?: Array<Metric>;
    /**
     * Name of the dashboard. 
     * @type {string}
     * @memberof Dashboard
     */
    name?: string;
}
/**
 * Schema for the request to update a data plane cluster\'s status
 * @export
 * @interface DataPlaneClusterUpdateStatusRequest
 */
export interface DataPlaneClusterUpdateStatusRequest {
    /**
     * The cluster data plane conditions
     * @type {Array<DataPlaneClusterUpdateStatusRequestConditions>}
     * @memberof DataPlaneClusterUpdateStatusRequest
     */
    conditions?: Array<DataPlaneClusterUpdateStatusRequestConditions>;
    /**
     * 
     * @type {DataPlaneClusterUpdateStatusRequestTotal}
     * @memberof DataPlaneClusterUpdateStatusRequest
     */
    total?: DataPlaneClusterUpdateStatusRequestTotal;
    /**
     * 
     * @type {DataPlaneClusterUpdateStatusRequestTotal}
     * @memberof DataPlaneClusterUpdateStatusRequest
     */
    remaining?: DataPlaneClusterUpdateStatusRequestTotal;
    /**
     * 
     * @type {DataPlaneClusterUpdateStatusRequestNodeInfo}
     * @memberof DataPlaneClusterUpdateStatusRequest
     */
    nodeInfo?: DataPlaneClusterUpdateStatusRequestNodeInfo;
    /**
     * 
     * @type {DataPlaneClusterUpdateStatusRequestResizeInfo}
     * @memberof DataPlaneClusterUpdateStatusRequest
     */
    resizeInfo?: DataPlaneClusterUpdateStatusRequestResizeInfo;
}
/**
 * 
 * @export
 * @interface DataPlaneClusterUpdateStatusRequestConditions
 */
export interface DataPlaneClusterUpdateStatusRequestConditions {
    /**
     * 
     * @type {string}
     * @memberof DataPlaneClusterUpdateStatusRequestConditions
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof DataPlaneClusterUpdateStatusRequestConditions
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof DataPlaneClusterUpdateStatusRequestConditions
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof DataPlaneClusterUpdateStatusRequestConditions
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof DataPlaneClusterUpdateStatusRequestConditions
     */
    lastTransitionTime?: string;
}
/**
 * 
 * @export
 * @interface DataPlaneClusterUpdateStatusRequestNodeInfo
 */
export interface DataPlaneClusterUpdateStatusRequestNodeInfo {
    /**
     * 
     * @type {number}
     * @memberof DataPlaneClusterUpdateStatusRequestNodeInfo
     */
    ceiling?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPlaneClusterUpdateStatusRequestNodeInfo
     */
    floor?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPlaneClusterUpdateStatusRequestNodeInfo
     */
    current?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPlaneClusterUpdateStatusRequestNodeInfo
     */
    currentWorkLoadMinimum?: number | null;
}
/**
 * 
 * @export
 * @interface DataPlaneClusterUpdateStatusRequestResizeInfo
 */
export interface DataPlaneClusterUpdateStatusRequestResizeInfo {
    /**
     * 
     * @type {number}
     * @memberof DataPlaneClusterUpdateStatusRequestResizeInfo
     */
    nodeDelta?: number | null;
    /**
     * 
     * @type {DataPlaneClusterUpdateStatusRequestResizeInfoDelta}
     * @memberof DataPlaneClusterUpdateStatusRequestResizeInfo
     */
    delta?: DataPlaneClusterUpdateStatusRequestResizeInfoDelta | null;
}
/**
 * 
 * @export
 * @interface DataPlaneClusterUpdateStatusRequestResizeInfoDelta
 */
export interface DataPlaneClusterUpdateStatusRequestResizeInfoDelta {
    /**
     * 
     * @type {string}
     * @memberof DataPlaneClusterUpdateStatusRequestResizeInfoDelta
     */
    ingressEgressThroughputPerSec?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DataPlaneClusterUpdateStatusRequestResizeInfoDelta
     */
    connections?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DataPlaneClusterUpdateStatusRequestResizeInfoDelta
     */
    dataRetentionSize?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DataPlaneClusterUpdateStatusRequestResizeInfoDelta
     */
    partitions?: number | null;
}
/**
 * 
 * @export
 * @interface DataPlaneClusterUpdateStatusRequestTotal
 */
export interface DataPlaneClusterUpdateStatusRequestTotal {
    /**
     * 
     * @type {string}
     * @memberof DataPlaneClusterUpdateStatusRequestTotal
     */
    ingressEgressThroughputPerSec?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DataPlaneClusterUpdateStatusRequestTotal
     */
    connections?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DataPlaneClusterUpdateStatusRequestTotal
     */
    dataRetentionSize?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DataPlaneClusterUpdateStatusRequestTotal
     */
    partitions?: number | null;
}
/**
 * Schema of the status object for a Kafka cluster
 * @export
 * @interface DataPlaneKafkaStatus
 */
export interface DataPlaneKafkaStatus {
    /**
     * The status conditions of a Kafka cluster
     * @type {Array<DataPlaneClusterUpdateStatusRequestConditions>}
     * @memberof DataPlaneKafkaStatus
     */
    conditions?: Array<DataPlaneClusterUpdateStatusRequestConditions>;
    /**
     * 
     * @type {DataPlaneKafkaStatusCapacity}
     * @memberof DataPlaneKafkaStatus
     */
    capacity?: DataPlaneKafkaStatusCapacity;
    /**
     * 
     * @type {DataPlaneKafkaStatusVersions}
     * @memberof DataPlaneKafkaStatus
     */
    versions?: DataPlaneKafkaStatusVersions;
}
/**
 * Capacity information of the data plane cluster
 * @export
 * @interface DataPlaneKafkaStatusCapacity
 */
export interface DataPlaneKafkaStatusCapacity {
    /**
     * 
     * @type {string}
     * @memberof DataPlaneKafkaStatusCapacity
     */
    ingressEgressThroughputPerSec?: string;
    /**
     * 
     * @type {number}
     * @memberof DataPlaneKafkaStatusCapacity
     */
    totalMaxConnections?: number;
    /**
     * 
     * @type {string}
     * @memberof DataPlaneKafkaStatusCapacity
     */
    maxDataRetentionSize?: string;
    /**
     * 
     * @type {number}
     * @memberof DataPlaneKafkaStatusCapacity
     */
    maxPartitions?: number;
    /**
     * 
     * @type {string}
     * @memberof DataPlaneKafkaStatusCapacity
     */
    maxDataRetentionPeriod?: string;
}
/**
 * Version information related to a Kafka cluster
 * @export
 * @interface DataPlaneKafkaStatusVersions
 */
export interface DataPlaneKafkaStatusVersions {
    /**
     * 
     * @type {string}
     * @memberof DataPlaneKafkaStatusVersions
     */
    kafka?: string;
    /**
     * 
     * @type {string}
     * @memberof DataPlaneKafkaStatusVersions
     */
    strimzi?: string;
}
/**
 * Configuration for the data plane cluster agent
 * @export
 * @interface DataplaneClusterAgentConfig
 */
export interface DataplaneClusterAgentConfig {
    /**
     * 
     * @type {DataplaneClusterAgentConfigSpec}
     * @memberof DataplaneClusterAgentConfig
     */
    spec?: DataplaneClusterAgentConfigSpec;
}
/**
 * Data plane cluster agent spec
 * @export
 * @interface DataplaneClusterAgentConfigSpec
 */
export interface DataplaneClusterAgentConfigSpec {
    /**
     * 
     * @type {DataplaneClusterAgentConfigSpecObservability}
     * @memberof DataplaneClusterAgentConfigSpec
     */
    observability?: DataplaneClusterAgentConfigSpecObservability;
}
/**
 * Observability configurations
 * @export
 * @interface DataplaneClusterAgentConfigSpecObservability
 */
export interface DataplaneClusterAgentConfigSpecObservability {
    /**
     * 
     * @type {string}
     * @memberof DataplaneClusterAgentConfigSpecObservability
     */
    accessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof DataplaneClusterAgentConfigSpecObservability
     */
    channel?: string;
    /**
     * 
     * @type {string}
     * @memberof DataplaneClusterAgentConfigSpecObservability
     */
    repository?: string;
    /**
     * 
     * @type {string}
     * @memberof DataplaneClusterAgentConfigSpecObservability
     */
    tag?: string;
}
/**
 * 
 * @export
 * @interface Error1
 */
export interface Error1 {
    /**
     * Indicates the type of this object. Will always be \'Error\' 
     * @type {string}
     * @memberof Error1
     */
    kind?: string;
    /**
     * Numeric identifier of the error. 
     * @type {number}
     * @memberof Error1
     */
    id?: number;
    /**
     * Self link. 
     * @type {string}
     * @memberof Error1
     */
    href?: string;
    /**
     * Globally unique code of the error, composed of the unique identifier of the API and the numeric identifier of the error. For example, for if the numeric identifier of the error is `93` and the identifier of the API is `clusters_mgmt` then the code will be `CLUSTERS-MGMT-93`. 
     * @type {string}
     * @memberof Error1
     */
    code?: string;
    /**
     * Human readable description of the error. 
     * @type {string}
     * @memberof Error1
     */
    reason?: string;
    /**
     * Extra information about the error. 
     * @type {{ [key: string]: object; }}
     * @memberof Error1
     */
    details?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface ErrorAllOf
 */
export interface ErrorAllOf {
    /**
     * 
     * @type {string}
     * @memberof ErrorAllOf
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorAllOf
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorAllOf
     */
    operation_id?: string;
}
/**
 * 
 * @export
 * @interface ErrorList
 */
export interface ErrorList {
    /**
     * 
     * @type {string}
     * @memberof ErrorList
     */
    kind: string;
    /**
     * 
     * @type {number}
     * @memberof ErrorList
     */
    page: number;
    /**
     * 
     * @type {number}
     * @memberof ErrorList
     */
    size: number;
    /**
     * 
     * @type {number}
     * @memberof ErrorList
     */
    total: number;
    /**
     * 
     * @type {Array<Error>}
     * @memberof ErrorList
     */
    items: Array<Error>;
}
/**
 * 
 * @export
 * @interface ErrorListAllOf
 */
export interface ErrorListAllOf {
    /**
     * 
     * @type {Array<Error>}
     * @memberof ErrorListAllOf
     */
    items?: Array<Error>;
}
/**
 * Representation of cluster external configuration. 
 * @export
 * @interface ExternalConfiguration
 */
export interface ExternalConfiguration {
    /**
     * list of labels externally configured on the clusterdeployment. 
     * @type {Array<Label>}
     * @memberof ExternalConfiguration
     */
    labels?: Array<Label>;
    /**
     * list of syncsets externally configured on the cluster. 
     * @type {Array<Syncset>}
     * @memberof ExternalConfiguration
     */
    syncsets?: Array<Syncset>;
}
/**
 * Set of predefined properties of a cluster. For example, a _huge_ flavour can be a cluster with 10 infra nodes and 1000 compute nodes. 
 * @export
 * @interface Flavour
 */
export interface Flavour {
    /**
     * Indicates the type of this object. Will be \'Flavour\' if this is a complete object or \'FlavourLink\' if it is just a link. 
     * @type {string}
     * @memberof Flavour
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof Flavour
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof Flavour
     */
    href?: string;
    /**
     * 
     * @type {AWSFlavour}
     * @memberof Flavour
     */
    aws?: AWSFlavour;
    /**
     * 
     * @type {GCPFlavour}
     * @memberof Flavour
     */
    gcp?: GCPFlavour;
    /**
     * Human friendly identifier of the cluster, for example `4`.  NOTE: Currently for all flavours the `id` and `name` attributes have exactly the same values. 
     * @type {string}
     * @memberof Flavour
     */
    name?: string;
    /**
     * 
     * @type {Network}
     * @memberof Flavour
     */
    network?: Network;
    /**
     * 
     * @type {FlavourNodes}
     * @memberof Flavour
     */
    nodes?: FlavourNodes;
}
/**
 * Counts of different classes of nodes inside a flavour. 
 * @export
 * @interface FlavourNodes
 */
export interface FlavourNodes {
    /**
     * Number of master nodes of the cluster. 
     * @type {number}
     * @memberof FlavourNodes
     */
    master?: number;
}
/**
 * Google cloud platform settings of a cluster. 
 * @export
 * @interface GCP
 */
export interface GCP {
    /**
     * GCP authentication uri 
     * @type {string}
     * @memberof GCP
     */
    auth_uri?: string;
    /**
     * GCP Authentication provider x509 certificate url 
     * @type {string}
     * @memberof GCP
     */
    auth_provider_x509_cert_url?: string;
    /**
     * GCP client identifier 
     * @type {string}
     * @memberof GCP
     */
    client_id?: string;
    /**
     * GCP client x509 certificate url 
     * @type {string}
     * @memberof GCP
     */
    client_x509_cert_url?: string;
    /**
     * GCP client email 
     * @type {string}
     * @memberof GCP
     */
    client_email?: string;
    /**
     * GCP private key 
     * @type {string}
     * @memberof GCP
     */
    private_key?: string;
    /**
     * GCP private key identifier 
     * @type {string}
     * @memberof GCP
     */
    private_key_id?: string;
    /**
     * GCP project identifier. 
     * @type {string}
     * @memberof GCP
     */
    project_id?: string;
    /**
     * GCP token uri 
     * @type {string}
     * @memberof GCP
     */
    token_uri?: string;
    /**
     * GCP the type of the service the key belongs to 
     * @type {string}
     * @memberof GCP
     */
    type?: string;
}
/**
 * Specification for different classes of nodes inside a flavour. 
 * @export
 * @interface GCPFlavour
 */
export interface GCPFlavour {
    /**
     * GCP default instance type for the worker volume.  User can be overridden specifying in the cluster itself a type for compute node. 
     * @type {string}
     * @memberof GCPFlavour
     */
    compute_instance_type?: string;
    /**
     * GCP default instance type for the infra volume. 
     * @type {string}
     * @memberof GCPFlavour
     */
    infra_instance_type?: string;
    /**
     * GCP default instance type for the master volume. 
     * @type {string}
     * @memberof GCPFlavour
     */
    master_instance_type?: string;
}
/**
 * Details for `github` identity providers. 
 * @export
 * @interface GithubIdentityProvider
 */
export interface GithubIdentityProvider {
    /**
     * Optional trusted certificate authority bundle to use when making requests tot he server. 
     * @type {string}
     * @memberof GithubIdentityProvider
     */
    ca?: string;
    /**
     * Client identifier of a registered _GitHub_ OAuth application. 
     * @type {string}
     * @memberof GithubIdentityProvider
     */
    client_id?: string;
    /**
     * Client secret of a registered _GitHub_ OAuth application. 
     * @type {string}
     * @memberof GithubIdentityProvider
     */
    client_secret?: string;
    /**
     * For _GitHub Enterprise_ you must provide the host name of your instance, such as `example.com`. This value must match the _GitHub Enterprise_ host name value in the `/setup/settings` file and cannot include a port number.  For plain _GitHub_ omit this parameter. 
     * @type {string}
     * @memberof GithubIdentityProvider
     */
    hostname?: string;
    /**
     * Optional list of organizations. Cannot be used in combination with the Teams field. 
     * @type {Array<string>}
     * @memberof GithubIdentityProvider
     */
    organizations?: Array<string>;
    /**
     * Optional list of teams. Cannot be used in combination with the Organizations field. 
     * @type {Array<string>}
     * @memberof GithubIdentityProvider
     */
    teams?: Array<string>;
}
/**
 * Details for `gitlab` identity providers. 
 * @export
 * @interface GitlabIdentityProvider
 */
export interface GitlabIdentityProvider {
    /**
     * Optional trusted certificate authority bundle to use when making requests tot he server. 
     * @type {string}
     * @memberof GitlabIdentityProvider
     */
    ca?: string;
    /**
     * URL of the _GitLab_ instance. 
     * @type {string}
     * @memberof GitlabIdentityProvider
     */
    url?: string;
    /**
     * Client identifier of a registered _GitLab_ OAuth application. 
     * @type {string}
     * @memberof GitlabIdentityProvider
     */
    client_id?: string;
    /**
     * Client secret issued by _GitLab_. 
     * @type {string}
     * @memberof GitlabIdentityProvider
     */
    client_secret?: string;
}
/**
 * Details for `google` identity providers. 
 * @export
 * @interface GoogleIdentityProvider
 */
export interface GoogleIdentityProvider {
    /**
     * Client identifier of a registered _Google_ project. 
     * @type {string}
     * @memberof GoogleIdentityProvider
     */
    client_id?: string;
    /**
     * Client secret issued by _Google_. 
     * @type {string}
     * @memberof GoogleIdentityProvider
     */
    client_secret?: string;
    /**
     * Optional hosted domain to restrict sign-in accounts to. 
     * @type {string}
     * @memberof GoogleIdentityProvider
     */
    hosted_domain?: string;
}
/**
 * Representation of a group of users. 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * Indicates the type of this object. Will be \'Group\' if this is a complete object or \'GroupLink\' if it is just a link. 
     * @type {string}
     * @memberof Group
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof Group
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof Group
     */
    href?: string;
    /**
     * List of users of the group. 
     * @type {Array<User>}
     * @memberof Group
     */
    users?: Array<User>;
}
/**
 * Details for `htpasswd` identity providers. 
 * @export
 * @interface HTPasswdIdentityProvider
 */
export interface HTPasswdIdentityProvider {
    /**
     * Password to be used in the _HTPasswd_ data file. 
     * @type {string}
     * @memberof HTPasswdIdentityProvider
     */
    password?: string;
    /**
     * Username to be used in the _HTPasswd_ data file. 
     * @type {string}
     * @memberof HTPasswdIdentityProvider
     */
    username?: string;
}
/**
 * Representation of an identity provider. 
 * @export
 * @interface IdentityProvider
 */
export interface IdentityProvider {
    /**
     * Indicates the type of this object. Will be \'IdentityProvider\' if this is a complete object or \'IdentityProviderLink\' if it is just a link. 
     * @type {string}
     * @memberof IdentityProvider
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof IdentityProvider
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof IdentityProvider
     */
    href?: string;
    /**
     * 
     * @type {LDAPIdentityProvider}
     * @memberof IdentityProvider
     */
    ldap?: LDAPIdentityProvider;
    /**
     * When `true` unauthenticated token requests from non-web clients (like the CLI) are sent a `WWW-Authenticate` challenge header for this provider. 
     * @type {boolean}
     * @memberof IdentityProvider
     */
    challenge?: boolean;
    /**
     * 
     * @type {GithubIdentityProvider}
     * @memberof IdentityProvider
     */
    github?: GithubIdentityProvider;
    /**
     * 
     * @type {GitlabIdentityProvider}
     * @memberof IdentityProvider
     */
    gitlab?: GitlabIdentityProvider;
    /**
     * 
     * @type {GoogleIdentityProvider}
     * @memberof IdentityProvider
     */
    google?: GoogleIdentityProvider;
    /**
     * 
     * @type {HTPasswdIdentityProvider}
     * @memberof IdentityProvider
     */
    htpasswd?: HTPasswdIdentityProvider;
    /**
     * When `true` unauthenticated token requests from web clients (like the web console) are redirected to the authorize URL to log in. 
     * @type {boolean}
     * @memberof IdentityProvider
     */
    login?: boolean;
    /**
     * 
     * @type {IdentityProviderMappingMethod}
     * @memberof IdentityProvider
     */
    mapping_method?: IdentityProviderMappingMethod;
    /**
     * The name of the identity provider. 
     * @type {string}
     * @memberof IdentityProvider
     */
    name?: string;
    /**
     * 
     * @type {OpenIDIdentityProvider}
     * @memberof IdentityProvider
     */
    open_id?: OpenIDIdentityProvider;
    /**
     * 
     * @type {IdentityProviderType}
     * @memberof IdentityProvider
     */
    type?: IdentityProviderType;
}
/**
 * Controls how mappings are established between provider identities and user objects. 
 * @export
 * @enum {string}
 */
export enum IdentityProviderMappingMethod {
    Add = 'add',
    Claim = 'claim',
    Generate = 'generate',
    Lookup = 'lookup'
}

/**
 * Type of identity provider. 
 * @export
 * @enum {string}
 */
export enum IdentityProviderType {
    Ldap = 'ldap',
    Github = 'github',
    Gitlab = 'gitlab',
    Google = 'google',
    Htpasswd = 'htpasswd',
    OpenId = 'open_id'
}

/**
 * Representation of an ingress. 
 * @export
 * @interface Ingress
 */
export interface Ingress {
    /**
     * Indicates the type of this object. Will be \'Ingress\' if this is a complete object or \'IngressLink\' if it is just a link. 
     * @type {string}
     * @memberof Ingress
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof Ingress
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof Ingress
     */
    href?: string;
    /**
     * DNS Name of the ingress. 
     * @type {string}
     * @memberof Ingress
     */
    dns_name?: string;
    /**
     * 
     * @type {Cluster}
     * @memberof Ingress
     */
    cluster?: Cluster;
    /**
     * Indicates if this is the default ingress. 
     * @type {boolean}
     * @memberof Ingress
     */
    _default?: boolean;
    /**
     * 
     * @type {ListeningMethod}
     * @memberof Ingress
     */
    listening?: ListeningMethod;
    /**
     * A set of labels for the ingress.  
     * @type {{ [key: string]: string; }}
     * @memberof Ingress
     */
    route_selectors?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * Retrieved list of add-ons. 
     * @type {Array<AddOn>}
     * @memberof InlineResponse200
     */
    items?: Array<AddOn>;
    /**
     * Index of the requested page, where one corresponds to the first page. 
     * @type {number}
     * @memberof InlineResponse200
     */
    page?: number;
    /**
     * Maximum number of items that will be contained in the returned page. 
     * @type {number}
     * @memberof InlineResponse200
     */
    size?: number;
    /**
     * Total number of items of the collection that match the search criteria, regardless of the size of the page. 
     * @type {number}
     * @memberof InlineResponse200
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * Retrieved list of roles. 
     * @type {Array<AWSInfrastructureAccessRole>}
     * @memberof InlineResponse2001
     */
    items?: Array<AWSInfrastructureAccessRole>;
    /**
     * Index of the requested page, where one corresponds to the first page. 
     * @type {number}
     * @memberof InlineResponse2001
     */
    page?: number;
    /**
     * Maximum number of items that will be contained in the returned page. 
     * @type {number}
     * @memberof InlineResponse2001
     */
    size?: number;
    /**
     * Total number of items of the collection that match the search criteria, regardless of the size of the page. 
     * @type {number}
     * @memberof InlineResponse2001
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * Retrieved list of groups. 
     * @type {Array<Group>}
     * @memberof InlineResponse20010
     */
    items?: Array<Group>;
    /**
     * Index of the requested page, where one corresponds to the first page. 
     * @type {number}
     * @memberof InlineResponse20010
     */
    page?: number;
    /**
     * Number of items contained in the returned page. 
     * @type {number}
     * @memberof InlineResponse20010
     */
    size?: number;
    /**
     * Total number of items of the collection. 
     * @type {number}
     * @memberof InlineResponse20010
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * Retrieved list of users. 
     * @type {Array<User>}
     * @memberof InlineResponse20011
     */
    items?: Array<User>;
    /**
     * Index of the requested page, where one corresponds to the first page. 
     * @type {number}
     * @memberof InlineResponse20011
     */
    page?: number;
    /**
     * Number of items contained in the returned page. 
     * @type {number}
     * @memberof InlineResponse20011
     */
    size?: number;
    /**
     * Total number of items of the collection. 
     * @type {number}
     * @memberof InlineResponse20011
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * Retrieved list of identity providers. 
     * @type {Array<IdentityProvider>}
     * @memberof InlineResponse20012
     */
    items?: Array<IdentityProvider>;
    /**
     * Index of the requested page, where one corresponds to the first page. 
     * @type {number}
     * @memberof InlineResponse20012
     */
    page?: number;
    /**
     * Number of items contained in the returned page. 
     * @type {number}
     * @memberof InlineResponse20012
     */
    size?: number;
    /**
     * Total number of items of the collection. 
     * @type {number}
     * @memberof InlineResponse20012
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     * Retrieved list of ingresses. 
     * @type {Array<Ingress>}
     * @memberof InlineResponse20013
     */
    items?: Array<Ingress>;
    /**
     * Index of the requested page, where one corresponds to the first page. 
     * @type {number}
     * @memberof InlineResponse20013
     */
    page?: number;
    /**
     * Number of items contained in the returned page. 
     * @type {number}
     * @memberof InlineResponse20013
     */
    size?: number;
    /**
     * Total number of items of the collection. 
     * @type {number}
     * @memberof InlineResponse20013
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
    /**
     * Retrieved list of log links. 
     * @type {Array<Log>}
     * @memberof InlineResponse20014
     */
    items?: Array<Log>;
    /**
     * Index of the requested page, where one corresponds to the first page. 
     * @type {number}
     * @memberof InlineResponse20014
     */
    page?: number;
    /**
     * Number of items contained in the returned page. 
     * @type {number}
     * @memberof InlineResponse20014
     */
    size?: number;
    /**
     * Total number of items of the collection. 
     * @type {number}
     * @memberof InlineResponse20014
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
    /**
     * Retrieved list of machine pools. 
     * @type {Array<MachinePool>}
     * @memberof InlineResponse20015
     */
    items?: Array<MachinePool>;
    /**
     * Index of the requested page, where one corresponds to the first page. 
     * @type {number}
     * @memberof InlineResponse20015
     */
    page?: number;
    /**
     * Number of items contained in the returned page. 
     * @type {number}
     * @memberof InlineResponse20015
     */
    size?: number;
    /**
     * Total number of items of the collection. 
     * @type {number}
     * @memberof InlineResponse20015
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20016
 */
export interface InlineResponse20016 {
    /**
     * Retrieved list of upgrade policy. 
     * @type {Array<UpgradePolicy>}
     * @memberof InlineResponse20016
     */
    items?: Array<UpgradePolicy>;
    /**
     * Index of the requested page, where one corresponds to the first page. 
     * @type {number}
     * @memberof InlineResponse20016
     */
    page?: number;
    /**
     * Number of items contained in the returned page. 
     * @type {number}
     * @memberof InlineResponse20016
     */
    size?: number;
    /**
     * Total number of items of the collection. 
     * @type {number}
     * @memberof InlineResponse20016
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20017
 */
export interface InlineResponse20017 {
    /**
     * Retrieved list of dashboards. 
     * @type {Array<Dashboard>}
     * @memberof InlineResponse20017
     */
    items?: Array<Dashboard>;
    /**
     * Index of the requested page, where one corresponds to the first page. 
     * @type {number}
     * @memberof InlineResponse20017
     */
    page?: number;
    /**
     * Maximum number of items that will be contained in the returned page. 
     * @type {number}
     * @memberof InlineResponse20017
     */
    size?: number;
    /**
     * Total number of items of the collection that match the search criteria, regardless of the size of the page. 
     * @type {number}
     * @memberof InlineResponse20017
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20018
 */
export interface InlineResponse20018 {
    /**
     * Retrieved list of flavours. 
     * @type {Array<Flavour>}
     * @memberof InlineResponse20018
     */
    items?: Array<Flavour>;
    /**
     * Index of the requested page, where one corresponds to the first page. 
     * @type {number}
     * @memberof InlineResponse20018
     */
    page?: number;
    /**
     * Maximum number of items that will be contained in the returned page. 
     * @type {number}
     * @memberof InlineResponse20018
     */
    size?: number;
    /**
     * Total number of items of the collection that match the search criteria, regardless of the size of the page. 
     * @type {number}
     * @memberof InlineResponse20018
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20019
 */
export interface InlineResponse20019 {
    /**
     * Retrieved list of cloud providers. 
     * @type {Array<MachineType>}
     * @memberof InlineResponse20019
     */
    items?: Array<MachineType>;
    /**
     * Index of the requested page, where one corresponds to the first page. 
     * @type {number}
     * @memberof InlineResponse20019
     */
    page?: number;
    /**
     * Maximum number of items that will be contained in the returned page. 
     * @type {number}
     * @memberof InlineResponse20019
     */
    size?: number;
    /**
     * Total number of items of the collection that match the search criteria, regardless of the size of the page. 
     * @type {number}
     * @memberof InlineResponse20019
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * Retrieved list of cloud providers. 
     * @type {Array<CloudProvider1>}
     * @memberof InlineResponse2002
     */
    items?: Array<CloudProvider1>;
    /**
     * Index of the requested page, where one corresponds to the first page. 
     * @type {number}
     * @memberof InlineResponse2002
     */
    page?: number;
    /**
     * Maximum number of items that will be contained in the returned page. 
     * @type {number}
     * @memberof InlineResponse2002
     */
    size?: number;
    /**
     * Total number of items of the collection that match the search criteria, regardless of the size of the page. 
     * @type {number}
     * @memberof InlineResponse2002
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20020
 */
export interface InlineResponse20020 {
    /**
     * Retrieved list of products. 
     * @type {Array<Product>}
     * @memberof InlineResponse20020
     */
    items?: Array<Product>;
    /**
     * Index of the requested page, where one corresponds to the first page. 
     * @type {number}
     * @memberof InlineResponse20020
     */
    page?: number;
    /**
     * Maximum number of items that will be contained in the returned page. 
     * @type {number}
     * @memberof InlineResponse20020
     */
    size?: number;
    /**
     * Total number of items of the collection that match the search criteria, regardless of the size of the page. 
     * @type {number}
     * @memberof InlineResponse20020
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20021
 */
export interface InlineResponse20021 {
    /**
     * Retrieved a list of provision shards. 
     * @type {Array<ProvisionShard>}
     * @memberof InlineResponse20021
     */
    items?: Array<ProvisionShard>;
    /**
     * Index of the requested page, where one corresponds to the first page. 
     * @type {number}
     * @memberof InlineResponse20021
     */
    page?: number;
    /**
     * Maximum number of items that will be contained in the returned page. 
     * @type {number}
     * @memberof InlineResponse20021
     */
    size?: number;
    /**
     * Total number of items of the collection. 
     * @type {number}
     * @memberof InlineResponse20021
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20022
 */
export interface InlineResponse20022 {
    /**
     * Retrieved list of versions. 
     * @type {Array<Version>}
     * @memberof InlineResponse20022
     */
    items?: Array<Version>;
    /**
     * Index of the requested page, where one corresponds to the first page. 
     * @type {number}
     * @memberof InlineResponse20022
     */
    page?: number;
    /**
     * Maximum number of items that will be contained in the returned page.  Default value is `100`. 
     * @type {number}
     * @memberof InlineResponse20022
     */
    size?: number;
    /**
     * Total number of items of the collection that match the search criteria, regardless of the size of the page. 
     * @type {number}
     * @memberof InlineResponse20022
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * Retrieved list of cloud regions. 
     * @type {Array<CloudRegion1>}
     * @memberof InlineResponse2003
     */
    items?: Array<CloudRegion1>;
    /**
     * Index of the returned page, where one corresponds to the first page. As this collection doesn\'t support paging the result will always be `1`. 
     * @type {number}
     * @memberof InlineResponse2003
     */
    page?: number;
    /**
     * Number of items that will be contained in the returned page. As this collection doesn\'t support paging or searching the result will always be the total number of regions of the provider. 
     * @type {number}
     * @memberof InlineResponse2003
     */
    size?: number;
    /**
     * Total number of items of the collection that match the search criteria, regardless of the size of the page. As this collection doesn\'t support paging or searching the result will always be the total number of available regions of the provider. 
     * @type {number}
     * @memberof InlineResponse2003
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * Retrieved list of cloud providers. 
     * @type {Array<CloudRegion1>}
     * @memberof InlineResponse2004
     */
    items?: Array<CloudRegion1>;
    /**
     * Index of the returned page, where one corresponds to the first page. As this collection doesn\'t support paging the result will always be `1`. 
     * @type {number}
     * @memberof InlineResponse2004
     */
    page?: number;
    /**
     * Number of items that will be contained in the returned page. As this collection doesn\'t support paging or searching the result will always be the total number of regions of the provider. 
     * @type {number}
     * @memberof InlineResponse2004
     */
    size?: number;
    /**
     * Total number of items of the collection that match the search criteria, regardless of the size of the page. As this collection doesn\'t support paging or searching the result will always be the total number of regions of the provider. 
     * @type {number}
     * @memberof InlineResponse2004
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * Retrieved list of clusters. 
     * @type {Array<Cluster>}
     * @memberof InlineResponse2005
     */
    items?: Array<Cluster>;
    /**
     * Index of the requested page, where one corresponds to the first page. 
     * @type {number}
     * @memberof InlineResponse2005
     */
    page?: number;
    /**
     * Maximum number of items that will be contained in the returned page. 
     * @type {number}
     * @memberof InlineResponse2005
     */
    size?: number;
    /**
     * Total number of items of the collection that match the search criteria, regardless of the size of the page. 
     * @type {number}
     * @memberof InlineResponse2005
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * Retrieved list of add-on installations. 
     * @type {Array<AddOnInstallation>}
     * @memberof InlineResponse2006
     */
    items?: Array<AddOnInstallation>;
    /**
     * Index of the requested page, where one corresponds to the first page. 
     * @type {number}
     * @memberof InlineResponse2006
     */
    page?: number;
    /**
     * Maximum number of items that will be contained in the returned page. 
     * @type {number}
     * @memberof InlineResponse2006
     */
    size?: number;
    /**
     * Total number of items of the collection that match the search criteria, regardless of the size of the page. 
     * @type {number}
     * @memberof InlineResponse2006
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * Retrieved list of AWS infrastructure access role grants. 
     * @type {Array<AWSInfrastructureAccessRoleGrant>}
     * @memberof InlineResponse2007
     */
    items?: Array<AWSInfrastructureAccessRoleGrant>;
    /**
     * Index of the requested page, where one corresponds to the first page. 
     * @type {number}
     * @memberof InlineResponse2007
     */
    page?: number;
    /**
     * Maximum number of items that will be contained in the returned page. 
     * @type {number}
     * @memberof InlineResponse2007
     */
    size?: number;
    /**
     * Total number of items of the collection that match the search criteria, regardless of the size of the page. 
     * @type {number}
     * @memberof InlineResponse2007
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * Retrieved list of labels. 
     * @type {Array<Label>}
     * @memberof InlineResponse2008
     */
    items?: Array<Label>;
    /**
     * Index of the requested page, where one corresponds to the first page. 
     * @type {number}
     * @memberof InlineResponse2008
     */
    page?: number;
    /**
     * Number of items contained in the returned page. 
     * @type {number}
     * @memberof InlineResponse2008
     */
    size?: number;
    /**
     * Total number of items of the collection. 
     * @type {number}
     * @memberof InlineResponse2008
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * Retrieved list of syncsets. 
     * @type {Array<Syncset>}
     * @memberof InlineResponse2009
     */
    items?: Array<Syncset>;
    /**
     * Index of the requested page, where one corresponds to the first page. 
     * @type {number}
     * @memberof InlineResponse2009
     */
    page?: number;
    /**
     * Number of items contained in the returned page. 
     * @type {number}
     * @memberof InlineResponse2009
     */
    size?: number;
    /**
     * Total number of items of the collection. 
     * @type {number}
     * @memberof InlineResponse2009
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InstantQuery
 */
export interface InstantQuery {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InstantQuery
     */
    metric?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof InstantQuery
     */
    Timestamp?: number;
    /**
     * 
     * @type {number}
     * @memberof InstantQuery
     */
    Value: number;
}
/**
 * 
 * @export
 * @interface KafkaRequest
 */
export interface KafkaRequest {
    /**
     * 
     * @type {string}
     * @memberof KafkaRequest
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaRequest
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaRequest
     */
    href?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaRequest
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaRequest
     */
    cloud_provider?: string;
    /**
     * 
     * @type {boolean}
     * @memberof KafkaRequest
     */
    multi_az?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KafkaRequest
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaRequest
     */
    bootstrapServerHost?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaRequest
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaRequest
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaRequest
     */
    failed_reason?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaRequest
     */
    version?: string;
}
/**
 * 
 * @export
 * @interface KafkaRequestAllOf
 */
export interface KafkaRequestAllOf {
    /**
     * 
     * @type {string}
     * @memberof KafkaRequestAllOf
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaRequestAllOf
     */
    cloud_provider?: string;
    /**
     * 
     * @type {boolean}
     * @memberof KafkaRequestAllOf
     */
    multi_az?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KafkaRequestAllOf
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaRequestAllOf
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaRequestAllOf
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaRequestAllOf
     */
    bootstrapServerHost?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaRequestAllOf
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaRequestAllOf
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaRequestAllOf
     */
    failed_reason?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaRequestAllOf
     */
    version?: string;
}
/**
 * 
 * @export
 * @interface KafkaRequestList
 */
export interface KafkaRequestList {
    /**
     * 
     * @type {string}
     * @memberof KafkaRequestList
     */
    kind: string;
    /**
     * 
     * @type {number}
     * @memberof KafkaRequestList
     */
    page: number;
    /**
     * 
     * @type {number}
     * @memberof KafkaRequestList
     */
    size: number;
    /**
     * 
     * @type {number}
     * @memberof KafkaRequestList
     */
    total: number;
    /**
     * 
     * @type {Array<KafkaRequest>}
     * @memberof KafkaRequestList
     */
    items: Array<KafkaRequest>;
}
/**
 * 
 * @export
 * @interface KafkaRequestListAllOf
 */
export interface KafkaRequestListAllOf {
    /**
     * 
     * @type {Array<KafkaRequest>}
     * @memberof KafkaRequestListAllOf
     */
    items?: Array<KafkaRequest>;
}
/**
 * Schema for the request body sent to /kafkas POST
 * @export
 * @interface KafkaRequestPayload
 */
export interface KafkaRequestPayload {
    /**
     * The cloud provider where the Kafka cluster will be created in
     * @type {string}
     * @memberof KafkaRequestPayload
     */
    cloud_provider?: string;
    /**
     * Set this to true to configure the Kafka cluster to be multiAZ
     * @type {boolean}
     * @memberof KafkaRequestPayload
     */
    multi_az?: boolean;
    /**
     * The name of the Kafka cluster. It must consist of lower-case alphanumeric characters or \'-\', start with an alphabetic character, and end with an alphanumeric character, and can not be longer than 32 characters.
     * @type {string}
     * @memberof KafkaRequestPayload
     */
    name: string;
    /**
     * The region where the Kafka cluster will be created in
     * @type {string}
     * @memberof KafkaRequestPayload
     */
    region?: string;
}
/**
 * LDAP attributes used to configure the LDAP identity provider. 
 * @export
 * @interface LDAPAttributes
 */
export interface LDAPAttributes {
    /**
     * List of attributes to use as the identity. 
     * @type {Array<string>}
     * @memberof LDAPAttributes
     */
    id?: Array<string>;
    /**
     * List of attributes to use as the mail address. 
     * @type {Array<string>}
     * @memberof LDAPAttributes
     */
    email?: Array<string>;
    /**
     * List of attributes to use as the display name. 
     * @type {Array<string>}
     * @memberof LDAPAttributes
     */
    name?: Array<string>;
    /**
     * List of attributes to use as the preferred user name when provisioning a user. 
     * @type {Array<string>}
     * @memberof LDAPAttributes
     */
    preferred_username?: Array<string>;
}
/**
 * Details for `ldap` identity providers. 
 * @export
 * @interface LDAPIdentityProvider
 */
export interface LDAPIdentityProvider {
    /**
     * Certificate bundle to use to validate server certificates for the configured URL. 
     * @type {string}
     * @memberof LDAPIdentityProvider
     */
    ca?: string;
    /**
     * An https://tools.ietf.org/html/rfc2255[RFC 2255] URL which specifies the LDAP host and search parameters to use. 
     * @type {string}
     * @memberof LDAPIdentityProvider
     */
    url?: string;
    /**
     * 
     * @type {LDAPAttributes}
     * @memberof LDAPIdentityProvider
     */
    attributes?: LDAPAttributes;
    /**
     * Optional distinguished name to use to bind during the search phase. 
     * @type {string}
     * @memberof LDAPIdentityProvider
     */
    bind_dn?: string;
    /**
     * Optional password to use to bind during the search phase. 
     * @type {string}
     * @memberof LDAPIdentityProvider
     */
    bind_password?: string;
    /**
     * When `true` no TLS connection is made to the server. When `false` `ldaps://...` URLs connect using TLS and `ldap://...` are upgraded to TLS. 
     * @type {boolean}
     * @memberof LDAPIdentityProvider
     */
    insecure?: boolean;
}
/**
 * Representation of a label in clusterdeployment. 
 * @export
 * @interface Label
 */
export interface Label {
    /**
     * Indicates the type of this object. Will be \'Label\' if this is a complete object or \'LabelLink\' if it is just a link. 
     * @type {string}
     * @memberof Label
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof Label
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof Label
     */
    href?: string;
    /**
     * the key of the label 
     * @type {string}
     * @memberof Label
     */
    key?: string;
    /**
     * the value to set in the label 
     * @type {string}
     * @memberof Label
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface List
 */
export interface List {
    /**
     * 
     * @type {string}
     * @memberof List
     */
    kind: string;
    /**
     * 
     * @type {number}
     * @memberof List
     */
    page: number;
    /**
     * 
     * @type {number}
     * @memberof List
     */
    size: number;
    /**
     * 
     * @type {number}
     * @memberof List
     */
    total: number;
}
/**
 * 
 * @export
 * @interface ListReference
 */
export interface ListReference {
    /**
     * 
     * @type {string}
     * @memberof ListReference
     */
    kind: string;
}
/**
 * Cluster components listening method. 
 * @export
 * @enum {string}
 */
export enum ListeningMethod {
    External = 'external',
    Internal = 'internal'
}

/**
 * Log of the cluster. 
 * @export
 * @interface Log
 */
export interface Log {
    /**
     * Indicates the type of this object. Will be \'Log\' if this is a complete object or \'LogLink\' if it is just a link. 
     * @type {string}
     * @memberof Log
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof Log
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof Log
     */
    href?: string;
    /**
     * Content of the log. 
     * @type {string}
     * @memberof Log
     */
    content?: string;
}
/**
 * Representation of a machine pool in a cluster. 
 * @export
 * @interface MachinePool
 */
export interface MachinePool {
    /**
     * Indicates the type of this object. Will be \'MachinePool\' if this is a complete object or \'MachinePoolLink\' if it is just a link. 
     * @type {string}
     * @memberof MachinePool
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof MachinePool
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof MachinePool
     */
    href?: string;
    /**
     * 
     * @type {MachinePoolAutoscaling}
     * @memberof MachinePool
     */
    autoscaling?: MachinePoolAutoscaling;
    /**
     * The availability zones upon which the nodes are created. 
     * @type {Array<string>}
     * @memberof MachinePool
     */
    availability_zones?: Array<string>;
    /**
     * 
     * @type {Cluster}
     * @memberof MachinePool
     */
    cluster?: Cluster;
    /**
     * The instance type of Nodes to create. 
     * @type {string}
     * @memberof MachinePool
     */
    instance_type?: string;
    /**
     * The labels set on the Nodes created. 
     * @type {{ [key: string]: string; }}
     * @memberof MachinePool
     */
    labels?: { [key: string]: string; };
    /**
     * The number of Machines (and Nodes) to create. Replicas and autoscaling cannot be used together.     
     * @type {number}
     * @memberof MachinePool
     */
    replicas?: number;
    /**
     * The taints set on the Nodes created. 
     * @type {Array<Taint>}
     * @memberof MachinePool
     */
    taints?: Array<Taint>;
}
/**
 * Representation of a autoscaling in a machine pool. 
 * @export
 * @interface MachinePoolAutoscaling
 */
export interface MachinePoolAutoscaling {
    /**
     * Indicates the type of this object. Will be \'MachinePoolAutoscaling\' if this is a complete object or \'MachinePoolAutoscalingLink\' if it is just a link. 
     * @type {string}
     * @memberof MachinePoolAutoscaling
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof MachinePoolAutoscaling
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof MachinePoolAutoscaling
     */
    href?: string;
    /**
     * The maximum number of replicas for the machine pool. 
     * @type {number}
     * @memberof MachinePoolAutoscaling
     */
    max_replicas?: number;
    /**
     * The minimum number of replicas for the machine pool. 
     * @type {number}
     * @memberof MachinePoolAutoscaling
     */
    min_replicas?: number;
}
/**
 * Machine type. 
 * @export
 * @interface MachineType
 */
export interface MachineType {
    /**
     * Indicates the type of this object. Will be \'MachineType\' if this is a complete object or \'MachineTypeLink\' if it is just a link. 
     * @type {string}
     * @memberof MachineType
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof MachineType
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof MachineType
     */
    href?: string;
    /**
     * 
     * @type {Value}
     * @memberof MachineType
     */
    cpu?: Value;
    /**
     * 
     * @type {MachineTypeCategory}
     * @memberof MachineType
     */
    category?: MachineTypeCategory;
    /**
     * 
     * @type {CloudProvider1}
     * @memberof MachineType
     */
    cloud_provider?: CloudProvider1;
    /**
     * 
     * @type {Value}
     * @memberof MachineType
     */
    memory?: Value;
    /**
     * Human friendly identifier of the machine type, for example `r5.xlarge - Memory Optimized`. 
     * @type {string}
     * @memberof MachineType
     */
    name?: string;
    /**
     * 
     * @type {MachineTypeSize}
     * @memberof MachineType
     */
    size?: MachineTypeSize;
}
/**
 * Machine type category. 
 * @export
 * @enum {string}
 */
export enum MachineTypeCategory {
    ComputeOptimized = 'compute_optimized',
    GeneralPurpose = 'general_purpose',
    MemoryOptimized = 'memory_optimized'
}

/**
 * Machine type size. 
 * @export
 * @enum {string}
 */
export enum MachineTypeSize {
    Large = 'large',
    Medium = 'medium',
    Small = 'small'
}

/**
 * 
 * @export
 * @interface ManagedKafka
 */
export interface ManagedKafka {
    /**
     * 
     * @type {string}
     * @memberof ManagedKafka
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedKafka
     */
    kind?: string;
    /**
     * 
     * @type {ManagedKafkaAllOfMetadata}
     * @memberof ManagedKafka
     */
    metadata?: ManagedKafkaAllOfMetadata;
    /**
     * 
     * @type {ManagedKafkaAllOfSpec}
     * @memberof ManagedKafka
     */
    spec?: ManagedKafkaAllOfSpec;
}
/**
 * 
 * @export
 * @interface ManagedKafkaAllOf
 */
export interface ManagedKafkaAllOf {
    /**
     * 
     * @type {ManagedKafkaAllOfMetadata}
     * @memberof ManagedKafkaAllOf
     */
    metadata?: ManagedKafkaAllOfMetadata;
    /**
     * 
     * @type {ManagedKafkaAllOfSpec}
     * @memberof ManagedKafkaAllOf
     */
    spec?: ManagedKafkaAllOfSpec;
}
/**
 * 
 * @export
 * @interface ManagedKafkaAllOfMetadata
 */
export interface ManagedKafkaAllOfMetadata {
    /**
     * 
     * @type {string}
     * @memberof ManagedKafkaAllOfMetadata
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedKafkaAllOfMetadata
     */
    namespace?: string;
    /**
     * 
     * @type {ManagedKafkaAllOfMetadataAnnotations}
     * @memberof ManagedKafkaAllOfMetadata
     */
    annotations?: ManagedKafkaAllOfMetadataAnnotations;
}
/**
 * 
 * @export
 * @interface ManagedKafkaAllOfMetadataAnnotations
 */
export interface ManagedKafkaAllOfMetadataAnnotations {
    /**
     * 
     * @type {string}
     * @memberof ManagedKafkaAllOfMetadataAnnotations
     */
    bf2_org_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedKafkaAllOfMetadataAnnotations
     */
    bf2_org_placementId?: string;
}
/**
 * 
 * @export
 * @interface ManagedKafkaAllOfSpec
 */
export interface ManagedKafkaAllOfSpec {
    /**
     * 
     * @type {ManagedKafkaCapacity}
     * @memberof ManagedKafkaAllOfSpec
     */
    capacity?: ManagedKafkaCapacity;
    /**
     * 
     * @type {ManagedKafkaAllOfSpecOauth}
     * @memberof ManagedKafkaAllOfSpec
     */
    oauth?: ManagedKafkaAllOfSpecOauth;
    /**
     * 
     * @type {ManagedKafkaAllOfSpecEndpoint}
     * @memberof ManagedKafkaAllOfSpec
     */
    endpoint?: ManagedKafkaAllOfSpecEndpoint;
    /**
     * 
     * @type {ManagedKafkaVersions}
     * @memberof ManagedKafkaAllOfSpec
     */
    versions?: ManagedKafkaVersions;
    /**
     * 
     * @type {boolean}
     * @memberof ManagedKafkaAllOfSpec
     */
    deleted: boolean;
}
/**
 * 
 * @export
 * @interface ManagedKafkaAllOfSpecEndpoint
 */
export interface ManagedKafkaAllOfSpecEndpoint {
    /**
     * 
     * @type {string}
     * @memberof ManagedKafkaAllOfSpecEndpoint
     */
    bootstrapServerHost?: string;
    /**
     * 
     * @type {ManagedKafkaAllOfSpecEndpointTls}
     * @memberof ManagedKafkaAllOfSpecEndpoint
     */
    tls?: ManagedKafkaAllOfSpecEndpointTls;
}
/**
 * 
 * @export
 * @interface ManagedKafkaAllOfSpecEndpointTls
 */
export interface ManagedKafkaAllOfSpecEndpointTls {
    /**
     * 
     * @type {string}
     * @memberof ManagedKafkaAllOfSpecEndpointTls
     */
    cert?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedKafkaAllOfSpecEndpointTls
     */
    key?: string;
}
/**
 * 
 * @export
 * @interface ManagedKafkaAllOfSpecOauth
 */
export interface ManagedKafkaAllOfSpecOauth {
    /**
     * 
     * @type {string}
     * @memberof ManagedKafkaAllOfSpecOauth
     */
    clientId?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedKafkaAllOfSpecOauth
     */
    clientSecret?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedKafkaAllOfSpecOauth
     */
    tokenEndpointURI?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedKafkaAllOfSpecOauth
     */
    jwksEndpointURI?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedKafkaAllOfSpecOauth
     */
    validIssuerEndpointURI?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedKafkaAllOfSpecOauth
     */
    userNameClaim?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedKafkaAllOfSpecOauth
     */
    tlsTrustedCertificate?: string;
}
/**
 * 
 * @export
 * @interface ManagedKafkaCapacity
 */
export interface ManagedKafkaCapacity {
    /**
     * 
     * @type {string}
     * @memberof ManagedKafkaCapacity
     */
    ingressEgressThroughputPerSec?: string;
    /**
     * 
     * @type {number}
     * @memberof ManagedKafkaCapacity
     */
    totalMaxConnections?: number;
    /**
     * 
     * @type {string}
     * @memberof ManagedKafkaCapacity
     */
    maxDataRetentionSize?: string;
    /**
     * 
     * @type {number}
     * @memberof ManagedKafkaCapacity
     */
    maxPartitions?: number;
    /**
     * 
     * @type {string}
     * @memberof ManagedKafkaCapacity
     */
    maxDataRetentionPeriod?: string;
}
/**
 * A list of ManagedKafka
 * @export
 * @interface ManagedKafkaList
 */
export interface ManagedKafkaList {
    /**
     * 
     * @type {string}
     * @memberof ManagedKafkaList
     */
    kind: string;
    /**
     * 
     * @type {Array<ManagedKafka>}
     * @memberof ManagedKafkaList
     */
    items: Array<ManagedKafka>;
}
/**
 * 
 * @export
 * @interface ManagedKafkaListAllOf
 */
export interface ManagedKafkaListAllOf {
    /**
     * 
     * @type {Array<ManagedKafka>}
     * @memberof ManagedKafkaListAllOf
     */
    items?: Array<ManagedKafka>;
}
/**
 * 
 * @export
 * @interface ManagedKafkaVersions
 */
export interface ManagedKafkaVersions {
    /**
     * 
     * @type {string}
     * @memberof ManagedKafkaVersions
     */
    kafka?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedKafkaVersions
     */
    strimzi?: string;
}
/**
 * 
 * @export
 * @interface MetaV1Condition
 */
export interface MetaV1Condition {
    /**
     * 
     * @type {string}
     * @memberof MetaV1Condition
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof MetaV1Condition
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof MetaV1Condition
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof MetaV1Condition
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof MetaV1Condition
     */
    lastTransitionTime?: string;
}
/**
 * Version metadata. 
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * Version of the server. 
     * @type {string}
     * @memberof Metadata
     */
    server_version?: string;
}
/**
 * Metric included in a dashboard. 
 * @export
 * @interface Metric
 */
export interface Metric {
    /**
     * Name of the metric. 
     * @type {string}
     * @memberof Metric
     */
    name?: string;
    /**
     * Samples of the metric. 
     * @type {Array<Sample>}
     * @memberof Metric
     */
    vector?: Array<Sample>;
}
/**
 * 
 * @export
 * @interface MetricsInstantQueryList
 */
export interface MetricsInstantQueryList {
    /**
     * 
     * @type {string}
     * @memberof MetricsInstantQueryList
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsInstantQueryList
     */
    id?: string;
    /**
     * 
     * @type {Array<InstantQuery>}
     * @memberof MetricsInstantQueryList
     */
    items?: Array<InstantQuery>;
}
/**
 * 
 * @export
 * @interface MetricsInstantQueryListAllOf
 */
export interface MetricsInstantQueryListAllOf {
    /**
     * 
     * @type {string}
     * @memberof MetricsInstantQueryListAllOf
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsInstantQueryListAllOf
     */
    id?: string;
    /**
     * 
     * @type {Array<InstantQuery>}
     * @memberof MetricsInstantQueryListAllOf
     */
    items?: Array<InstantQuery>;
}
/**
 * 
 * @export
 * @interface MetricsRangeQueryList
 */
export interface MetricsRangeQueryList {
    /**
     * 
     * @type {string}
     * @memberof MetricsRangeQueryList
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsRangeQueryList
     */
    id?: string;
    /**
     * 
     * @type {Array<RangeQuery>}
     * @memberof MetricsRangeQueryList
     */
    items?: Array<RangeQuery>;
}
/**
 * 
 * @export
 * @interface MetricsRangeQueryListAllOf
 */
export interface MetricsRangeQueryListAllOf {
    /**
     * 
     * @type {string}
     * @memberof MetricsRangeQueryListAllOf
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsRangeQueryListAllOf
     */
    id?: string;
    /**
     * 
     * @type {Array<RangeQuery>}
     * @memberof MetricsRangeQueryListAllOf
     */
    items?: Array<RangeQuery>;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    href?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    operation_id?: string;
}
/**
 * Network configuration of a cluster. 
 * @export
 * @interface Network
 */
export interface Network {
    /**
     * Network host prefix which is defaulted to `23` if not specified. 
     * @type {number}
     * @memberof Network
     */
    host_prefix?: number;
    /**
     * IP address block from which to assign machine IP addresses, for example `10.0.0.0/16`. 
     * @type {string}
     * @memberof Network
     */
    machine_cidr?: string;
    /**
     * IP address block from which to assign pod IP addresses, for example `10.128.0.0/14`. 
     * @type {string}
     * @memberof Network
     */
    pod_cidr?: string;
    /**
     * IP address block from which to assign service IP addresses, for example `172.30.0.0/16`. 
     * @type {string}
     * @memberof Network
     */
    service_cidr?: string;
}
/**
 * Provides information about a node from specific type in the cluster. 
 * @export
 * @interface NodeInfo
 */
export interface NodeInfo {
    /**
     * The amount of the nodes from this type. 
     * @type {number}
     * @memberof NodeInfo
     */
    amount?: number;
    /**
     * 
     * @type {NodeType}
     * @memberof NodeInfo
     */
    type?: NodeType;
}
/**
 * Type of node received via telemetry. 
 * @export
 * @enum {string}
 */
export enum NodeType {
    Compute = 'compute',
    Infra = 'infra',
    Master = 'master'
}

/**
 * Provides information about the nodes in the cluster. 
 * @export
 * @interface NodesInfo
 */
export interface NodesInfo {
    /**
     * 
     * @type {Array<NodeInfo>}
     * @memberof NodesInfo
     */
    nodes?: Array<NodeInfo>;
}
/**
 * 
 * @export
 * @interface ObjectReference
 */
export interface ObjectReference {
    /**
     * 
     * @type {string}
     * @memberof ObjectReference
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectReference
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectReference
     */
    href?: string;
}
/**
 * _OpenID_ identity provider claims. 
 * @export
 * @interface OpenIDClaims
 */
export interface OpenIDClaims {
    /**
     * List of claims to use as the mail address. 
     * @type {Array<string>}
     * @memberof OpenIDClaims
     */
    email?: Array<string>;
    /**
     * List of claims to use as the display name. 
     * @type {Array<string>}
     * @memberof OpenIDClaims
     */
    name?: Array<string>;
    /**
     * List of claims to use as the preferred user name when provisioning a user. 
     * @type {Array<string>}
     * @memberof OpenIDClaims
     */
    preferred_username?: Array<string>;
}
/**
 * Details for `openid` identity providers. 
 * @export
 * @interface OpenIDIdentityProvider
 */
export interface OpenIDIdentityProvider {
    /**
     * Certificate bunde to use to validate server certificates for the configured URL. 
     * @type {string}
     * @memberof OpenIDIdentityProvider
     */
    ca?: string;
    /**
     * 
     * @type {OpenIDClaims}
     * @memberof OpenIDIdentityProvider
     */
    claims?: OpenIDClaims;
    /**
     * Identifier of a client registered with the _OpenID_ provider. 
     * @type {string}
     * @memberof OpenIDIdentityProvider
     */
    client_id?: string;
    /**
     * Client secret. 
     * @type {string}
     * @memberof OpenIDIdentityProvider
     */
    client_secret?: string;
    /**
     * Optional map of extra parameters to add to the authorization token request. 
     * @type {{ [key: string]: string; }}
     * @memberof OpenIDIdentityProvider
     */
    extra_authorize_parameters?: { [key: string]: string; };
    /**
     * Optional list of scopes to request, in addition to the `openid` scope, during the authorization token request. 
     * @type {Array<string>}
     * @memberof OpenIDIdentityProvider
     */
    extra_scopes?: Array<string>;
    /**
     * The URL that the OpenID Provider asserts as the Issuer Identifier 
     * @type {string}
     * @memberof OpenIDIdentityProvider
     */
    issuer?: string;
}
/**
 * 
 * @export
 * @interface PrivateObjectReference
 */
export interface PrivateObjectReference {
    /**
     * 
     * @type {string}
     * @memberof PrivateObjectReference
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PrivateObjectReference
     */
    kind?: string;
}
/**
 * Representation of an product that can be selected as a cluster type. 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * Indicates the type of this object. Will be \'Product\' if this is a complete object or \'ProductLink\' if it is just a link. 
     * @type {string}
     * @memberof Product
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof Product
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof Product
     */
    href?: string;
    /**
     * Name of the product. 
     * @type {string}
     * @memberof Product
     */
    name?: string;
}
/**
 * Contains the properties of the provision shard, including AWS and GCP related configurations 
 * @export
 * @interface ProvisionShard
 */
export interface ProvisionShard {
    /**
     * Indicates the type of this object. Will be \'ProvisionShard\' if this is a complete object or \'ProvisionShardLink\' if it is just a link. 
     * @type {string}
     * @memberof ProvisionShard
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof ProvisionShard
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof ProvisionShard
     */
    href?: string;
    /**
     * 
     * @type {ServerConfig}
     * @memberof ProvisionShard
     */
    aws_account_operator_config?: ServerConfig;
    /**
     * Contains the AWS base domain 
     * @type {string}
     * @memberof ProvisionShard
     */
    aws_base_domain?: string;
    /**
     * Contains the GCP base domain 
     * @type {string}
     * @memberof ProvisionShard
     */
    gcp_base_domain?: string;
    /**
     * 
     * @type {ServerConfig}
     * @memberof ProvisionShard
     */
    gcp_project_operator?: ServerConfig;
    /**
     * 
     * @type {ServerConfig}
     * @memberof ProvisionShard
     */
    hive_config?: ServerConfig;
}
/**
 * 
 * @export
 * @interface RangeQuery
 */
export interface RangeQuery {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RangeQuery
     */
    metric?: { [key: string]: string; };
    /**
     * 
     * @type {Array<Values>}
     * @memberof RangeQuery
     */
    values?: Array<Values>;
}
/**
 * SSH key pair of a cluster. 
 * @export
 * @interface SSHCredentials
 */
export interface SSHCredentials {
    /**
     * SSH private key of the cluster. 
     * @type {string}
     * @memberof SSHCredentials
     */
    private_key?: string;
    /**
     * SSH public key of the cluster. 
     * @type {string}
     * @memberof SSHCredentials
     */
    public_key?: string;
}
/**
 * Sample of a metric. 
 * @export
 * @interface Sample
 */
export interface Sample {
    /**
     * Time when the sample was obtained. 
     * @type {string}
     * @memberof Sample
     */
    time?: string;
    /**
     * Numeric value of the sample. 
     * @type {number}
     * @memberof Sample
     */
    value?: number;
}
/**
 * Representation of a server config 
 * @export
 * @interface ServerConfig
 */
export interface ServerConfig {
    /**
     * Indicates the type of this object. Will be \'ServerConfig\' if this is a complete object or \'ServerConfigLink\' if it is just a link. 
     * @type {string}
     * @memberof ServerConfig
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof ServerConfig
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof ServerConfig
     */
    href?: string;
    /**
     * The URL of the server 
     * @type {string}
     * @memberof ServerConfig
     */
    server?: string;
}
/**
 * Service Account created in MAS-SSO for the Kafka Cluster for authentication
 * @export
 * @interface ServiceAccount
 */
export interface ServiceAccount {
    /**
     * server generated unique id of the service account
     * @type {string}
     * @memberof ServiceAccount
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccount
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccount
     */
    href?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccount
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccount
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccount
     */
    clientID?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccount
     */
    clientSecret?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccount
     */
    owner?: string;
}
/**
 * 
 * @export
 * @interface ServiceAccountAllOf
 */
export interface ServiceAccountAllOf {
    /**
     * server generated unique id of the service account
     * @type {string}
     * @memberof ServiceAccountAllOf
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountAllOf
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountAllOf
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountAllOf
     */
    clientID?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountAllOf
     */
    clientSecret?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountAllOf
     */
    owner?: string;
}
/**
 * 
 * @export
 * @interface ServiceAccountList
 */
export interface ServiceAccountList {
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountList
     */
    kind?: string;
    /**
     * 
     * @type {Array<ServiceAccountListItem>}
     * @memberof ServiceAccountList
     */
    items?: Array<ServiceAccountListItem>;
}
/**
 * 
 * @export
 * @interface ServiceAccountListAllOf
 */
export interface ServiceAccountListAllOf {
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountListAllOf
     */
    kind?: string;
    /**
     * 
     * @type {Array<ServiceAccountListItem>}
     * @memberof ServiceAccountListAllOf
     */
    items?: Array<ServiceAccountListItem>;
}
/**
 * 
 * @export
 * @interface ServiceAccountListItem
 */
export interface ServiceAccountListItem {
    /**
     * server generated unique id of the service account
     * @type {string}
     * @memberof ServiceAccountListItem
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountListItem
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountListItem
     */
    href?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountListItem
     */
    clientID?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountListItem
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountListItem
     */
    owner?: string;
    /**
     * 
     * @type {any}
     * @memberof ServiceAccountListItem
     */
    description?: any | null;
}
/**
 * 
 * @export
 * @interface ServiceAccountListItemAllOf
 */
export interface ServiceAccountListItemAllOf {
    /**
     * server generated unique id of the service account
     * @type {string}
     * @memberof ServiceAccountListItemAllOf
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountListItemAllOf
     */
    clientID?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountListItemAllOf
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountListItemAllOf
     */
    owner?: string;
    /**
     * 
     * @type {any}
     * @memberof ServiceAccountListItemAllOf
     */
    description?: any | null;
}
/**
 * Schema for the request to create a service account
 * @export
 * @interface ServiceAccountRequest
 */
export interface ServiceAccountRequest {
    /**
     * The name of the service account
     * @type {string}
     * @memberof ServiceAccountRequest
     */
    name: string;
    /**
     * A description for the service account
     * @type {string}
     * @memberof ServiceAccountRequest
     */
    description?: string;
}
/**
 * Schema for the service status response body
 * @export
 * @interface ServiceStatus
 */
export interface ServiceStatus {
    /**
     * 
     * @type {ServiceStatusKafkas}
     * @memberof ServiceStatus
     */
    kafkas?: ServiceStatusKafkas;
}
/**
 * The kafka resource api status
 * @export
 * @interface ServiceStatusKafkas
 */
export interface ServiceStatusKafkas {
    /**
     * Indicates whether we have reached kafka maximum capacity
     * @type {boolean}
     * @memberof ServiceStatusKafkas
     */
    max_capacity_reached: boolean;
}
/**
 * Representation of information from telemetry about a the socket capacity by node role and OS. 
 * @export
 * @interface SocketTotalNodeRoleOSMetricNode
 */
export interface SocketTotalNodeRoleOSMetricNode {
    /**
     * Representation of the node role for a cluster. 
     * @type {Array<string>}
     * @memberof SocketTotalNodeRoleOSMetricNode
     */
    node_roles?: Array<string>;
    /**
     * The operating system. 
     * @type {string}
     * @memberof SocketTotalNodeRoleOSMetricNode
     */
    operating_system?: string;
    /**
     * The total socket capacity of nodes with this set of roles and operating system. 
     * @type {number}
     * @memberof SocketTotalNodeRoleOSMetricNode
     */
    socket_total?: number;
    /**
     * 
     * @type {string}
     * @memberof SocketTotalNodeRoleOSMetricNode
     */
    time?: string;
}
/**
 * Representation of information from telemetry about the socket capacity by node role and OS of a cluster. 
 * @export
 * @interface SocketTotalsNodeRoleOSMetricNode
 */
export interface SocketTotalsNodeRoleOSMetricNode {
    /**
     * 
     * @type {Array<SocketTotalNodeRoleOSMetricNode>}
     * @memberof SocketTotalsNodeRoleOSMetricNode
     */
    socket_totals?: Array<SocketTotalNodeRoleOSMetricNode>;
}
/**
 * Definition of a subscription. 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * Indicates the type of this object. Will be \'Subscription\' if this is a complete object or \'SubscriptionLink\' if it is just a link. 
     * @type {string}
     * @memberof Subscription
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof Subscription
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof Subscription
     */
    href?: string;
}
/**
 * Representation of a syncset. 
 * @export
 * @interface Syncset
 */
export interface Syncset {
    /**
     * Indicates the type of this object. Will be \'Syncset\' if this is a complete object or \'SyncsetLink\' if it is just a link. 
     * @type {string}
     * @memberof Syncset
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof Syncset
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof Syncset
     */
    href?: string;
    /**
     * List of k8s objects to configure for the cluster. 
     * @type {Array<object>}
     * @memberof Syncset
     */
    resources?: Array<object>;
}
/**
 * Representation of a Taint set on a MachinePool in a cluster. 
 * @export
 * @interface Taint
 */
export interface Taint {
    /**
     * The effect on the node for the pods matching the taint, i.e: NoSchedule, NoExecute, PreferNoSchedule. 
     * @type {string}
     * @memberof Taint
     */
    effect?: string;
    /**
     * The key for the taint 
     * @type {string}
     * @memberof Taint
     */
    key?: string;
    /**
     * The value for the taint. 
     * @type {string}
     * @memberof Taint
     */
    value?: string;
}
/**
 * Representation of an upgrade policy that can be set for a cluster. 
 * @export
 * @interface UpgradePolicy
 */
export interface UpgradePolicy {
    /**
     * Indicates the type of this object. Will be \'UpgradePolicy\' if this is a complete object or \'UpgradePolicyLink\' if it is just a link. 
     * @type {string}
     * @memberof UpgradePolicy
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof UpgradePolicy
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof UpgradePolicy
     */
    href?: string;
    /**
     * Cluster ID this upgrade policy is defined for. 
     * @type {string}
     * @memberof UpgradePolicy
     */
    cluster_id?: string;
    /**
     * Next time the upgrade should run. 
     * @type {string}
     * @memberof UpgradePolicy
     */
    next_run?: string;
    /**
     * Schedule cron expression that defines automatic upgrade scheduling. 
     * @type {string}
     * @memberof UpgradePolicy
     */
    schedule?: string;
    /**
     * Schedule type can be either \"manual\" (single execution) or \"automatic\" (re-occurring). 
     * @type {string}
     * @memberof UpgradePolicy
     */
    schedule_type?: string;
    /**
     * Upgrade type specify the type of the upgrade. Can be \"OSD\" or \"CVE\". 
     * @type {string}
     * @memberof UpgradePolicy
     */
    upgrade_type?: string;
    /**
     * Version is the desired upgrade version. 
     * @type {string}
     * @memberof UpgradePolicy
     */
    version?: string;
}
/**
 * Representation of an upgrade policy state that that is set for a cluster. 
 * @export
 * @interface UpgradePolicyState
 */
export interface UpgradePolicyState {
    /**
     * Indicates the type of this object. Will be \'UpgradePolicyState\' if this is a complete object or \'UpgradePolicyStateLink\' if it is just a link. 
     * @type {string}
     * @memberof UpgradePolicyState
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof UpgradePolicyState
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof UpgradePolicyState
     */
    href?: string;
    /**
     * Description of the state. 
     * @type {string}
     * @memberof UpgradePolicyState
     */
    description?: string;
    /**
     * State value, can be \'pending\', \'started\', \'delayed\', \'failed\' or \'completed\'. 
     * @type {string}
     * @memberof UpgradePolicyState
     */
    value?: string;
}
/**
 * Representation of a user. 
 * @export
 * @interface User
 */
export interface User {
    /**
     * Indicates the type of this object. Will be \'User\' if this is a complete object or \'UserLink\' if it is just a link. 
     * @type {string}
     * @memberof User
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof User
     */
    href?: string;
}
/**
 * Numeric value and the unit used to measure it.  Units are not mandatory, and they\'re not specified for some resources. For resources that use bytes, the accepted units are:  - 1 B = 1 byte - 1 KB = 10^3 bytes - 1 MB = 10^6 bytes - 1 GB = 10^9 bytes - 1 TB = 10^12 bytes - 1 PB = 10^15 bytes  - 1 B = 1 byte - 1 KiB = 2^10 bytes - 1 MiB = 2^20 bytes - 1 GiB = 2^30 bytes - 1 TiB = 2^40 bytes - 1 PiB = 2^50 bytes 
 * @export
 * @interface Value
 */
export interface Value {
    /**
     * Name of the unit used to measure the value. 
     * @type {string}
     * @memberof Value
     */
    unit?: string;
    /**
     * Numeric value. 
     * @type {number}
     * @memberof Value
     */
    value?: number;
}
/**
 * 
 * @export
 * @interface Values
 */
export interface Values {
    /**
     * 
     * @type {number}
     * @memberof Values
     */
    Timestamp?: number;
    /**
     * 
     * @type {number}
     * @memberof Values
     */
    Value: number;
}
/**
 * Representation of an _OpenShift_ version. 
 * @export
 * @interface Version
 */
export interface Version {
    /**
     * Indicates the type of this object. Will be \'Version\' if this is a complete object or \'VersionLink\' if it is just a link. 
     * @type {string}
     * @memberof Version
     */
    kind?: string;
    /**
     * Unique identifier of the object. 
     * @type {string}
     * @memberof Version
     */
    id?: string;
    /**
     * Self link. 
     * @type {string}
     * @memberof Version
     */
    href?: string;
    /**
     * ROSAEnabled indicates whether this version can be used to create ROSA clusters. 
     * @type {boolean}
     * @memberof Version
     */
    rosa_enabled?: boolean;
    /**
     * AvailableUpgrades is the list of versions this version can be upgraded to. 
     * @type {Array<string>}
     * @memberof Version
     */
    available_upgrades?: Array<string>;
    /**
     * ChannelGroup is the name of the group where this image belongs. ChannelGroup is a mechanism to partition the images to different groups, each image belongs to only a single group. 
     * @type {string}
     * @memberof Version
     */
    channel_group?: string;
    /**
     * Indicates if this should be selected as the default version when a cluster is created without specifying explicitly the version. 
     * @type {boolean}
     * @memberof Version
     */
    _default?: boolean;
    /**
     * Indicates if this version can be used to create clusters. 
     * @type {boolean}
     * @memberof Version
     */
    enabled?: boolean;
    /**
     * RawID is the id of the version - without channel group and prefix. 
     * @type {string}
     * @memberof Version
     */
    raw_id?: string;
}
/**
 * 
 * @export
 * @interface VersionMetadata
 */
export interface VersionMetadata {
    /**
     * 
     * @type {string}
     * @memberof VersionMetadata
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof VersionMetadata
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof VersionMetadata
     */
    href?: string;
    /**
     * 
     * @type {Array<ObjectReference>}
     * @memberof VersionMetadata
     */
    collections?: Array<ObjectReference>;
}
/**
 * 
 * @export
 * @interface VersionMetadataAllOf
 */
export interface VersionMetadataAllOf {
    /**
     * 
     * @type {Array<ObjectReference>}
     * @memberof VersionMetadataAllOf
     */
    collections?: Array<ObjectReference>;
}
/**
 * 
 * @export
 * @interface WatchEvent
 */
export interface WatchEvent {
    /**
     * 
     * @type {string}
     * @memberof WatchEvent
     */
    type: string;
    /**
     * 
     * @type {Error}
     * @memberof WatchEvent
     */
    error?: Error;
    /**
     * 
     * @type {object}
     * @memberof WatchEvent
     */
    object?: object | null;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the add-on. 
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdDelete: async (addonId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'addonId' is not null or undefined
            assertParamExists('apiClustersMgmtV1AddonsAddonIdDelete', 'addonId', addonId)
            const localVarPath = `/api/clusters_mgmt/v1/addons/{addon_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the add-on. 
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdGet: async (addonId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'addonId' is not null or undefined
            assertParamExists('apiClustersMgmtV1AddonsAddonIdGet', 'addonId', addonId)
            const localVarPath = `/api/clusters_mgmt/v1/addons/{addon_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the add-on. 
         * @param {string} addonId 
         * @param {AddOn} [addOn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdPatch: async (addonId: string, addOn?: AddOn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'addonId' is not null or undefined
            assertParamExists('apiClustersMgmtV1AddonsAddonIdPatch', 'addonId', addonId)
            const localVarPath = `/api/clusters_mgmt/v1/addons/{addon_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of add-ons. 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-ons descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to retrieve all the add-ons with a name starting with &#x60;my&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-ons that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsGet: async (order?: string, page?: number, search?: string, size?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/addons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new add-on and add it to the collection of add-ons. 
         * @param {AddOn} [addOn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsPost: async (addOn?: AddOn, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/addons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the aws infrastructure access role. 
         * @param {string} awsInfrastructureAccessRoleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet: async (awsInfrastructureAccessRoleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'awsInfrastructureAccessRoleId' is not null or undefined
            assertParamExists('apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet', 'awsInfrastructureAccessRoleId', awsInfrastructureAccessRoleId)
            const localVarPath = `/api/clusters_mgmt/v1/aws_infrastructure_access_roles/{aws_infrastructure_access_role_id}`
                .replace(`{${"aws_infrastructure_access_role_id"}}`, encodeURIComponent(String(awsInfrastructureAccessRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to sort the roles descending by dislay_name the value should be:   &#x60;&#x60;&#x60; display_name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to retrieve all the role with a name starting with &#x60;my&#x60;the value should be:   &#x60;&#x60;&#x60; display_name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the roles that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInfrastructureAccessRolesGet: async (order?: string, page?: number, search?: string, size?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/aws_infrastructure_access_roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of available regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider. 
         * @param {string} cloudProviderId 
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;. 
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider. 
         * @param {AWS} [aWS] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost: async (cloudProviderId: string, page?: number, size?: number, aWS?: AWS, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost', 'cloudProviderId', cloudProviderId)
            const localVarPath = `/api/clusters_mgmt/v1/cloud_providers/{cloud_provider_id}/available_regions`
                .replace(`{${"cloud_provider_id"}}`, encodeURIComponent(String(cloudProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aWS, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the cloud provider. 
         * @param {string} cloudProviderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdGet: async (cloudProviderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1CloudProvidersCloudProviderIdGet', 'cloudProviderId', cloudProviderId)
            const localVarPath = `/api/clusters_mgmt/v1/cloud_providers/{cloud_provider_id}`
                .replace(`{${"cloud_provider_id"}}`, encodeURIComponent(String(cloudProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of regions of the provider. 
         * @param {string} cloudProviderId 
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;. 
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet: async (cloudProviderId: string, page?: number, size?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet', 'cloudProviderId', cloudProviderId)
            const localVarPath = `/api/clusters_mgmt/v1/cloud_providers/{cloud_provider_id}/regions`
                .replace(`{${"cloud_provider_id"}}`, encodeURIComponent(String(cloudProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the region. 
         * @param {string} cloudProviderId 
         * @param {string} regionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet: async (cloudProviderId: string, regionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet', 'cloudProviderId', cloudProviderId)
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet', 'regionId', regionId)
            const localVarPath = `/api/clusters_mgmt/v1/cloud_providers/{cloud_provider_id}/regions/{region_id}`
                .replace(`{${"cloud_provider_id"}}`, encodeURIComponent(String(cloudProviderId)))
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of cloud providers. 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to sort the clusters descending by name identifier the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to retrieve all the cloud providers with a name starting with &#x60;A&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersGet: async (order?: string, page?: number, search?: string, size?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/cloud_providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an add-on installation and remove it from the collection of add-on installations on the cluster. 
         * @param {string} clusterId 
         * @param {string} addoninstallationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete: async (clusterId: string, addoninstallationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete', 'clusterId', clusterId)
            // verify required parameter 'addoninstallationId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete', 'addoninstallationId', addoninstallationId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addons/{addoninstallation_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"addoninstallation_id"}}`, encodeURIComponent(String(addoninstallationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the add-on installation. 
         * @param {string} clusterId 
         * @param {string} addoninstallationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet: async (clusterId: string, addoninstallationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet', 'clusterId', clusterId)
            // verify required parameter 'addoninstallationId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet', 'addoninstallationId', addoninstallationId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addons/{addoninstallation_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"addoninstallation_id"}}`, encodeURIComponent(String(addoninstallationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the add-on installation. 
         * @param {string} clusterId 
         * @param {string} addoninstallationId 
         * @param {AddOnInstallation} [addOnInstallation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch: async (clusterId: string, addoninstallationId: string, addOnInstallation?: AddOnInstallation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch', 'clusterId', clusterId)
            // verify required parameter 'addoninstallationId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch', 'addoninstallationId', addoninstallationId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addons/{addoninstallation_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"addoninstallation_id"}}`, encodeURIComponent(String(addoninstallationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOnInstallation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of add-on installations. 
         * @param {string} clusterId 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to sort the add-on installations descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to retrieve all the add-on installations with a name starting with &#x60;my&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-on installations that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsGet: async (clusterId: string, order?: string, page?: number, search?: string, size?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addons`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new add-on installation and add it to the collection of add-on installations on the cluster. 
         * @param {string} clusterId 
         * @param {AddOnInstallation} [addOnInstallation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsPost: async (clusterId: string, addOnInstallation?: AddOnInstallation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonsPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addons`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOnInstallation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the AWS infrastructure access role grant. 
         * @param {string} clusterId 
         * @param {string} awsInfrastructureAccessRoleGrantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete: async (clusterId: string, awsInfrastructureAccessRoleGrantId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete', 'clusterId', clusterId)
            // verify required parameter 'awsInfrastructureAccessRoleGrantId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete', 'awsInfrastructureAccessRoleGrantId', awsInfrastructureAccessRoleGrantId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/aws_infrastructure_access_role_grants/{aws_infrastructure_access_role_grant_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"aws_infrastructure_access_role_grant_id"}}`, encodeURIComponent(String(awsInfrastructureAccessRoleGrantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the AWS infrastructure access role grant. 
         * @param {string} clusterId 
         * @param {string} awsInfrastructureAccessRoleGrantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet: async (clusterId: string, awsInfrastructureAccessRoleGrantId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet', 'clusterId', clusterId)
            // verify required parameter 'awsInfrastructureAccessRoleGrantId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet', 'awsInfrastructureAccessRoleGrantId', awsInfrastructureAccessRoleGrantId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/aws_infrastructure_access_role_grants/{aws_infrastructure_access_role_grant_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"aws_infrastructure_access_role_grant_id"}}`, encodeURIComponent(String(awsInfrastructureAccessRoleGrantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of AWS infrastructure access role grants. 
         * @param {string} clusterId 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to sort the AWS infrastructure access role grants descending by user ARN the value should be:   &#x60;&#x60;&#x60; user_arn desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to retrieve all the AWS infrastructure access role grants with a user ARN starting with &#x60;user&#x60; the value should be:   &#x60;&#x60;&#x60; user_arn like \&#39;%user\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the AWS infrastructure access role grants that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet: async (clusterId: string, order?: string, page?: number, search?: string, size?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/aws_infrastructure_access_role_grants`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new AWS infrastructure access role grant and add it to the collection of AWS infrastructure access role grants on the cluster. 
         * @param {string} clusterId 
         * @param {AWSInfrastructureAccessRoleGrant} [aWSInfrastructureAccessRoleGrant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost: async (clusterId: string, aWSInfrastructureAccessRoleGrant?: AWSInfrastructureAccessRoleGrant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/aws_infrastructure_access_role_grants`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aWSInfrastructureAccessRoleGrant, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the credentials of a cluster. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdCredentialsGet: async (clusterId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdCredentialsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/credentials`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the cluster. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdDelete: async (clusterId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdDelete', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the external configuration. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet: async (clusterId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of labels. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet: async (clusterId: string, page?: number, size?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/labels`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the label. 
         * @param {string} clusterId 
         * @param {string} labelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete: async (clusterId: string, labelId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete', 'clusterId', clusterId)
            // verify required parameter 'labelId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete', 'labelId', labelId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/labels/{label_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the label. 
         * @param {string} clusterId 
         * @param {string} labelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet: async (clusterId: string, labelId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet', 'clusterId', clusterId)
            // verify required parameter 'labelId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet', 'labelId', labelId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/labels/{label_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the label. 
         * @param {string} clusterId 
         * @param {string} labelId 
         * @param {Label} [label] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch: async (clusterId: string, labelId: string, label?: Label, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch', 'clusterId', clusterId)
            // verify required parameter 'labelId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch', 'labelId', labelId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/labels/{label_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(label, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new label to the cluster. 
         * @param {string} clusterId 
         * @param {Label} [label] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost: async (clusterId: string, label?: Label, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/labels`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(label, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of syncsets. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet: async (clusterId: string, page?: number, size?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/syncsets`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new syncset to the cluster. 
         * @param {string} clusterId 
         * @param {Syncset} [syncset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost: async (clusterId: string, syncset?: Syncset, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/syncsets`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the syncset. 
         * @param {string} clusterId 
         * @param {string} syncsetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete: async (clusterId: string, syncsetId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete', 'clusterId', clusterId)
            // verify required parameter 'syncsetId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete', 'syncsetId', syncsetId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/syncsets/{syncset_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"syncset_id"}}`, encodeURIComponent(String(syncsetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the syncset. 
         * @param {string} clusterId 
         * @param {string} syncsetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet: async (clusterId: string, syncsetId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet', 'clusterId', clusterId)
            // verify required parameter 'syncsetId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet', 'syncsetId', syncsetId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/syncsets/{syncset_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"syncset_id"}}`, encodeURIComponent(String(syncsetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the syncset. 
         * @param {string} clusterId 
         * @param {string} syncsetId 
         * @param {Syncset} [syncset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch: async (clusterId: string, syncsetId: string, syncset?: Syncset, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch', 'clusterId', clusterId)
            // verify required parameter 'syncsetId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch', 'syncsetId', syncsetId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/syncsets/{syncset_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"syncset_id"}}`, encodeURIComponent(String(syncsetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the cluster. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGet: async (clusterId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of groups. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGet: async (clusterId: string, page?: number, size?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/groups`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the group. 
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet: async (clusterId: string, groupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet', 'clusterId', clusterId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet', 'groupId', groupId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/groups/{group_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of users. 
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet: async (clusterId: string, groupId: string, page?: number, size?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet', 'clusterId', clusterId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet', 'groupId', groupId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/groups/{group_id}/users`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new user to the group. 
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost: async (clusterId: string, groupId: string, user?: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost', 'clusterId', clusterId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost', 'groupId', groupId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/groups/{group_id}/users`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the user. 
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete: async (clusterId: string, groupId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete', 'clusterId', clusterId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete', 'groupId', groupId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete', 'userId', userId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/groups/{group_id}/users/{user_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the user. 
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet: async (clusterId: string, groupId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet', 'clusterId', clusterId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet', 'groupId', groupId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet', 'userId', userId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/groups/{group_id}/users/{user_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiates cluster hibernation. While hibernating a cluster will not consume any cloud provider infrastructure but will be counted for quota. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdHibernatePost: async (clusterId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdHibernatePost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/hibernate`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of identity providers. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet: async (clusterId: string, page?: number, size?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the identity provider. 
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete: async (clusterId: string, identityProviderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete', 'clusterId', clusterId)
            // verify required parameter 'identityProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete', 'identityProviderId', identityProviderId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"identity_provider_id"}}`, encodeURIComponent(String(identityProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the identity provider. 
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet: async (clusterId: string, identityProviderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet', 'clusterId', clusterId)
            // verify required parameter 'identityProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet', 'identityProviderId', identityProviderId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"identity_provider_id"}}`, encodeURIComponent(String(identityProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update identity provider in the cluster. 
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {IdentityProvider} [identityProvider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch: async (clusterId: string, identityProviderId: string, identityProvider?: IdentityProvider, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch', 'clusterId', clusterId)
            // verify required parameter 'identityProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch', 'identityProviderId', identityProviderId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"identity_provider_id"}}`, encodeURIComponent(String(identityProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityProvider, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new identity provider to the cluster. 
         * @param {string} clusterId 
         * @param {IdentityProvider} [identityProvider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost: async (clusterId: string, identityProvider?: IdentityProvider, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityProvider, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of ingresses. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesGet: async (clusterId: string, page?: number, size?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIngressesGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/ingresses`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the ingress. 
         * @param {string} clusterId 
         * @param {string} ingressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete: async (clusterId: string, ingressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete', 'clusterId', clusterId)
            // verify required parameter 'ingressId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete', 'ingressId', ingressId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/ingresses/{ingress_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"ingress_id"}}`, encodeURIComponent(String(ingressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the ingress. 
         * @param {string} clusterId 
         * @param {string} ingressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet: async (clusterId: string, ingressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet', 'clusterId', clusterId)
            // verify required parameter 'ingressId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet', 'ingressId', ingressId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/ingresses/{ingress_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"ingress_id"}}`, encodeURIComponent(String(ingressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the ingress. 
         * @param {string} clusterId 
         * @param {string} ingressId 
         * @param {Ingress} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch: async (clusterId: string, ingressId: string, ingress?: Ingress, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch', 'clusterId', clusterId)
            // verify required parameter 'ingressId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch', 'ingressId', ingressId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/ingresses/{ingress_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"ingress_id"}}`, encodeURIComponent(String(ingressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates all ingresses 
         * @param {string} clusterId 
         * @param {Array<Ingress>} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesPatch: async (clusterId: string, ingress?: Array<Ingress>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIngressesPatch', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/ingresses`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new ingress to the cluster. 
         * @param {string} clusterId 
         * @param {Ingress} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesPost: async (clusterId: string, ingress?: Ingress, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIngressesPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/ingresses`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of log links. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLogsGet: async (clusterId: string, page?: number, size?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdLogsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/logs`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the log. 
         * @param {string} clusterId 
         * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log. 
         * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLogsInstallGet: async (clusterId: string, offset?: number, tail?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdLogsInstallGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/logs/install`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (tail !== undefined) {
                localVarQueryParameter['tail'] = tail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the log. 
         * @param {string} clusterId 
         * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log. 
         * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLogsUninstallGet: async (clusterId: string, offset?: number, tail?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdLogsUninstallGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/logs/uninstall`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (tail !== undefined) {
                localVarQueryParameter['tail'] = tail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of machine pools. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsGet: async (clusterId: string, page?: number, size?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMachinePoolsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/machine_pools`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the machine pool. 
         * @param {string} clusterId 
         * @param {string} machinePoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete: async (clusterId: string, machinePoolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete', 'clusterId', clusterId)
            // verify required parameter 'machinePoolId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete', 'machinePoolId', machinePoolId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/machine_pools/{machine_pool_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"machine_pool_id"}}`, encodeURIComponent(String(machinePoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the machine pool. 
         * @param {string} clusterId 
         * @param {string} machinePoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet: async (clusterId: string, machinePoolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet', 'clusterId', clusterId)
            // verify required parameter 'machinePoolId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet', 'machinePoolId', machinePoolId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/machine_pools/{machine_pool_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"machine_pool_id"}}`, encodeURIComponent(String(machinePoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the machine pool. 
         * @param {string} clusterId 
         * @param {string} machinePoolId 
         * @param {MachinePool} [machinePool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch: async (clusterId: string, machinePoolId: string, machinePool?: MachinePool, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch', 'clusterId', clusterId)
            // verify required parameter 'machinePoolId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch', 'machinePoolId', machinePoolId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/machine_pools/{machine_pool_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"machine_pool_id"}}`, encodeURIComponent(String(machinePoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(machinePool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new machine pool to the cluster. 
         * @param {string} clusterId 
         * @param {MachinePool} [machinePool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsPost: async (clusterId: string, machinePool?: MachinePool, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMachinePoolsPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/machine_pools`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(machinePool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet: async (clusterId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/metric_queries/alerts`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet: async (clusterId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/metric_queries/cluster_operators`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the metrics. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet: async (clusterId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/metric_queries/cpu_total_by_node_roles_os`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet: async (clusterId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/metric_queries/nodes`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the metrics. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet: async (clusterId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/metric_queries/socket_total_by_node_roles_os`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the cluster. 
         * @param {string} clusterId 
         * @param {Cluster} [cluster] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdPatch: async (clusterId: string, cluster?: Cluster, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdPatch', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cluster, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the product. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdProductGet: async (clusterId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdProductGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/product`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the provision shard. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdProvisionShardGet: async (clusterId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdProvisionShardGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/provision_shard`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resumes from Hibernation. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdResumePost: async (clusterId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdResumePost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/resume`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdStatusGet: async (clusterId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdStatusGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/status`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of upgrade policies. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet: async (clusterId: string, page?: number, size?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new upgrade policy to the cluster. 
         * @param {string} clusterId 
         * @param {UpgradePolicy} [upgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost: async (clusterId: string, upgradePolicy?: UpgradePolicy, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upgradePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the upgrade policy. 
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete: async (clusterId: string, upgradePolicyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete', 'clusterId', clusterId)
            // verify required parameter 'upgradePolicyId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete', 'upgradePolicyId', upgradePolicyId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies/{upgrade_policy_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"upgrade_policy_id"}}`, encodeURIComponent(String(upgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the upgrade policy. 
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet: async (clusterId: string, upgradePolicyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet', 'clusterId', clusterId)
            // verify required parameter 'upgradePolicyId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet', 'upgradePolicyId', upgradePolicyId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies/{upgrade_policy_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"upgrade_policy_id"}}`, encodeURIComponent(String(upgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the upgrade policy. 
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {UpgradePolicy} [upgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch: async (clusterId: string, upgradePolicyId: string, upgradePolicy?: UpgradePolicy, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch', 'clusterId', clusterId)
            // verify required parameter 'upgradePolicyId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch', 'upgradePolicyId', upgradePolicyId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies/{upgrade_policy_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"upgrade_policy_id"}}`, encodeURIComponent(String(upgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upgradePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the upgrade policy state. 
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet: async (clusterId: string, upgradePolicyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet', 'clusterId', clusterId)
            // verify required parameter 'upgradePolicyId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet', 'upgradePolicyId', upgradePolicyId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies/{upgrade_policy_id}/state`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"upgrade_policy_id"}}`, encodeURIComponent(String(upgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the upgrade policy state. 
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {UpgradePolicyState} [upgradePolicyState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch: async (clusterId: string, upgradePolicyId: string, upgradePolicyState?: UpgradePolicyState, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch', 'clusterId', clusterId)
            // verify required parameter 'upgradePolicyId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch', 'upgradePolicyId', upgradePolicyId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies/{upgrade_policy_id}/state`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"upgrade_policy_id"}}`, encodeURIComponent(String(upgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upgradePolicyState, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of clusters. 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to sort the clusters descending by region identifier the value should be:   &#x60;&#x60;&#x60; region.id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to retrieve all the clusters with a name starting with &#x60;my&#x60; in the &#x60;us-east-1&#x60; region the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; and region.id &#x3D; \&#39;us-east-1\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersGet: async (order?: string, page?: number, search?: string, size?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provision a new cluster and add it to the collection of clusters.  See the `register_cluster` method for adding an existing cluster. 
         * @param {Cluster} [cluster] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersPost: async (cluster?: Cluster, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cluster, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the dashboard. 
         * @param {string} dashboardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1DashboardsDashboardIdGet: async (dashboardId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists('apiClustersMgmtV1DashboardsDashboardIdGet', 'dashboardId', dashboardId)
            const localVarPath = `/api/clusters_mgmt/v1/dashboards/{dashboard_id}`
                .replace(`{${"dashboard_id"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of dashboards. 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the dashboard instead of the names of the columns of a table. For example, in order to sort the dashboards descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the dashboard instead of the names of the columns of a table. For example, in order to retrieve all the dashboards with a name starting with &#x60;my&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the dashboards that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1DashboardsGet: async (order?: string, page?: number, search?: string, size?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/dashboards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the cluster flavour. 
         * @param {string} flavourId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursFlavourIdGet: async (flavourId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavourId' is not null or undefined
            assertParamExists('apiClustersMgmtV1FlavoursFlavourIdGet', 'flavourId', flavourId)
            const localVarPath = `/api/clusters_mgmt/v1/flavours/{flavour_id}`
                .replace(`{${"flavour_id"}}`, encodeURIComponent(String(flavourId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the flavour.  Attributes that can be updated are:  - `aws.infra_volume` - `aws.infra_instance_type` - `gcp.infra_instance_type` 
         * @param {string} flavourId 
         * @param {Flavour} [flavour] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursFlavourIdPatch: async (flavourId: string, flavour?: Flavour, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavourId' is not null or undefined
            assertParamExists('apiClustersMgmtV1FlavoursFlavourIdPatch', 'flavourId', flavourId)
            const localVarPath = `/api/clusters_mgmt/v1/flavours/{flavour_id}`
                .replace(`{${"flavour_id"}}`, encodeURIComponent(String(flavourId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flavour, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to sort the flavours descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to retrieve all the flavours with a name starting with &#x60;my&#x60;the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the flavours that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursGet: async (order?: string, page?: number, search?: string, size?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/flavours`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new cluster flavour. 
         * @param {Flavour} [flavour] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursPost: async (flavour?: Flavour, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/flavours`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flavour, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the version metadata. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1Get: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of machine types. 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to sort the machine types descending by name identifier the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to retrieve all the machine types with a name starting with &#x60;A&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the machine types that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1MachineTypesGet: async (order?: string, page?: number, search?: string, size?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/machine_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of products. 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to sort the products descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to retrieve all the products with a name starting with &#x60;my&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the products that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProductsGet: async (order?: string, page?: number, search?: string, size?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the product. 
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProductsProductIdGet: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ProductsProductIdGet', 'productId', productId)
            const localVarPath = `/api/clusters_mgmt/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProvisionShardsGet: async (page?: number, size?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/provision_shards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the provision shard. 
         * @param {string} provisionShardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProvisionShardsProvisionShardIdGet: async (provisionShardId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'provisionShardId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ProvisionShardsProvisionShardIdGet', 'provisionShardId', provisionShardId)
            const localVarPath = `/api/clusters_mgmt/v1/provision_shards/{provision_shard_id}`
                .replace(`{${"provision_shard_id"}}`, encodeURIComponent(String(provisionShardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of versions. 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to sort the versions descending by identifier the value should be:   &#x60;&#x60;&#x60; id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to retrieve all the versions that are enabled:   &#x60;&#x60;&#x60; enabled &#x3D; \&#39;t\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the versions that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page.  Default value is &#x60;100&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionsGet: async (order?: string, page?: number, search?: string, size?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the version. 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionsVersionIdGet: async (versionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('apiClustersMgmtV1VersionsVersionIdGet', 'versionId', versionId)
            const localVarPath = `/api/clusters_mgmt/v1/versions/{version_id}`
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new connector
         * @param {string} id The id of record
         * @param {boolean} async Perform the action in an asynchronous manner
         * @param {Connector} connector Connector data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnector: async (id: string, async: boolean, connector: Connector, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createConnector', 'id', id)
            // verify required parameter 'async' is not null or undefined
            assertParamExists('createConnector', 'async', async)
            // verify required parameter 'connector' is not null or undefined
            assertParamExists('createConnector', 'connector', connector)
            const localVarPath = `/api/managed-services-api/v1/kafkas/{id}/connector-deployments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (async !== undefined) {
                localVarQueryParameter['async'] = async;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connector, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new connector cluster
         * @param {string} id The id of record
         * @param {boolean} async Perform the action in an asynchronous manner
         * @param {ConnectorCluster} connectorCluster Connector cluster data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectorCluster: async (id: string, async: boolean, connectorCluster: ConnectorCluster, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createConnectorCluster', 'id', id)
            // verify required parameter 'async' is not null or undefined
            assertParamExists('createConnectorCluster', 'async', async)
            // verify required parameter 'connectorCluster' is not null or undefined
            assertParamExists('createConnectorCluster', 'connectorCluster', connectorCluster)
            const localVarPath = `/api/managed-services-api/v1/kafka-connector-clusters`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (async !== undefined) {
                localVarQueryParameter['async'] = async;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorCluster, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new kafka Request
         * @param {boolean} async Perform the action in an asynchronous manner
         * @param {KafkaRequestPayload} kafkaRequestPayload Kafka data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKafka: async (async: boolean, kafkaRequestPayload: KafkaRequestPayload, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'async' is not null or undefined
            assertParamExists('createKafka', 'async', async)
            // verify required parameter 'kafkaRequestPayload' is not null or undefined
            assertParamExists('createKafka', 'kafkaRequestPayload', kafkaRequestPayload)
            const localVarPath = `/api/managed-services-api/v1/kafkas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (async !== undefined) {
                localVarQueryParameter['async'] = async;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(kafkaRequestPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a service account
         * @param {ServiceAccountRequest} serviceAccountRequest service account request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAccount: async (serviceAccountRequest: ServiceAccountRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceAccountRequest' is not null or undefined
            assertParamExists('createServiceAccount', 'serviceAccountRequest', serviceAccountRequest)
            const localVarPath = `/api/managed-services-api/v1/serviceaccounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a connector
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnector: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteConnector', 'id', id)
            const localVarPath = `/api/managed-services-api/v1/kafkas/{id}/connector-deployments/{cid}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a connector cluster
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnectorCluster: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteConnectorCluster', 'id', id)
            const localVarPath = `/api/managed-services-api/v1/kafka-connector-clusters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a kafka request by id
         * @param {string} id The id of record
         * @param {boolean} async Perform the action in an asynchronous manner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKafkaById: async (id: string, async: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteKafkaById', 'id', id)
            // verify required parameter 'async' is not null or undefined
            assertParamExists('deleteKafkaById', 'async', async)
            const localVarPath = `/api/managed-services-api/v1/kafkas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (async !== undefined) {
                localVarQueryParameter['async'] = async;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete service account
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAccount: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteServiceAccount', 'id', id)
            const localVarPath = `/api/managed-services-api/v1/serviceaccounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a connector deployment
         * @param {string} id The id of record
         * @param {string} cid The id of the connector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnector: async (id: string, cid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getConnector', 'id', id)
            // verify required parameter 'cid' is not null or undefined
            assertParamExists('getConnector', 'cid', cid)
            const localVarPath = `/api/managed-services-api/v1/kafkas/{id}/connector-deployments/{cid}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a connector cluster
         * @param {string} id The id of record
         * @param {string} cid The id of the connector cluster
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorCluster: async (id: string, cid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getConnectorCluster', 'id', id)
            // verify required parameter 'cid' is not null or undefined
            assertParamExists('getConnectorCluster', 'cid', cid)
            const localVarPath = `/api/managed-services-api/v1/kafka-connector-clusters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a connector cluster\'s addon parameters
         * @param {string} id The id of record
         * @param {string} cid The id of the connector cluster
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorClusterAddonParameters: async (id: string, cid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getConnectorClusterAddonParameters', 'id', id)
            // verify required parameter 'cid' is not null or undefined
            assertParamExists('getConnectorClusterAddonParameters', 'cid', cid)
            const localVarPath = `/api/managed-services-api/v1/kafka-connector-clusters/{id}/addon-parameters`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a connector type by name and version
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorTypeByID: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getConnectorTypeByID', 'id', id)
            const localVarPath = `/api/managed-services-api/v1/connector-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the spec of the ManagedKafkaAgent CR spec
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKafkaAgent: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKafkaAgent', 'id', id)
            const localVarPath = `/api/managed-services-api/v1/agent-clusters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a kafka request by id
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKafkaById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKafkaById', 'id', id)
            const localVarPath = `/api/managed-services-api/v1/kafkas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of ManagedaKafkas for the specified agent cluster
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKafkas: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKafkas', 'id', id)
            const localVarPath = `/api/managed-services-api/v1/agent-clusters/{id}/kafkas`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get metrics with instant query by kafka id.
         * @param {string} id The id of record
         * @param {Array<string>} [filters] List of metrics to fetch. Fetch all metrics when empty. List entries are kafka internal metric names.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsByInstantQuery: async (id: string, filters?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMetricsByInstantQuery', 'id', id)
            const localVarPath = `/api/managed-services-api/v1/kafkas/{id}/metrics/query`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filters) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get metrics with timeseries range query by kafka id.
         * @param {string} id The id of record
         * @param {number} duration The length of time in minutes over which to return the metrics.
         * @param {number} interval The interval in seconds between data points.
         * @param {Array<string>} [filters] List of metrics to fetch. Fetch all metrics when empty. List entries are kafka internal metric names.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsByRangeQuery: async (id: string, duration: number, interval: number, filters?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMetricsByRangeQuery', 'id', id)
            // verify required parameter 'duration' is not null or undefined
            assertParamExists('getMetricsByRangeQuery', 'duration', duration)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getMetricsByRangeQuery', 'interval', interval)
            const localVarPath = `/api/managed-services-api/v1/kafkas/{id}/metrics/query_range`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (filters) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get service account by id
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAccountById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getServiceAccountById', 'id', id)
            const localVarPath = `/api/managed-services-api/v1/serviceaccounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the list of supported regions of the supported cloud provider.
         * @param {string} id The id of record
         * @param {string} [page] Page index
         * @param {string} [size] Number of items in each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCloudProviderRegions: async (id: string, page?: string, size?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listCloudProviderRegions', 'id', id)
            const localVarPath = `/api/managed-services-api/v1/cloud_providers/{id}/regions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the list of supported cloud providers.
         * @param {string} [page] Page index
         * @param {string} [size] Number of items in each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCloudProviders: async (page?: string, size?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/managed-services-api/v1/cloud_providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of connector types
         * @param {string} id The id of record
         * @param {string} [page] Page index
         * @param {string} [size] Number of items in each page
         * @param {number} [gtVersion] filters the connectors to those with a version greater than the given value
         * @param {boolean} [watch] watch for changes to the resources and return them as a stream of watch events. Specify gt_version to specify the starting point.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusterAsignedConnectors: async (id: string, page?: string, size?: string, gtVersion?: number, watch?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listClusterAsignedConnectors', 'id', id)
            const localVarPath = `/api/managed-services-api/v1/kafka-connector-clusters/{id}/connectors`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (gtVersion !== undefined) {
                localVarQueryParameter['gt_version'] = gtVersion;
            }

            if (watch !== undefined) {
                localVarQueryParameter['watch'] = watch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of connector clusters
         * @param {string} id The id of record
         * @param {string} [page] Page index
         * @param {string} [size] Number of items in each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectorClusters: async (id: string, page?: string, size?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listConnectorClusters', 'id', id)
            const localVarPath = `/api/managed-services-api/v1/kafka-connector-clusters`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of connector types
         * @param {string} [page] Page index
         * @param {string} [size] Number of items in each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectorTypes: async (page?: string, size?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/managed-services-api/v1/connector-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of connector types
         * @param {string} id The id of record
         * @param {string} [page] Page index
         * @param {string} [size] Number of items in each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectors: async (id: string, page?: string, size?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listConnectors', 'id', id)
            const localVarPath = `/api/managed-services-api/v1/kafkas/{id}/connector-deployments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of Kafka requests
         * @param {string} [page] Page index
         * @param {string} [size] Number of items in each page
         * @param {string} [orderBy] Specifies the order by criteria. The syntax of this parameter is similar to the syntax of the _order by_ clause of an SQL statement. Each query can be ordered by any of the kafkaRequests fields. For example, in order to retrieve all kafkas ordered by their name:  &#x60;&#x60;&#x60;sql name asc &#x60;&#x60;&#x60;  Or in order to retrieve all kafkas ordered by their name _and_ created date:  &#x60;&#x60;&#x60;sql name asc, created_at asc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the results will be ordered by name.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement. Allowed fields in the search are: cloud_provider, name, owner, region and status. Allowed comparators are &#x60;&lt;&gt;&#x60;, &#x60;&#x3D;&#x60; or &#x60;LIKE&#x60;. Allowed joins are &#x60;AND&#x60; and &#x60;OR&#x60;, however there is a limit of max 10 joins in the search query.  Examples:  To retrieve kafka request with name equal &#x60;my-kafka&#x60; and region equal &#x60;aws&#x60;, the value should be:  &#x60;&#x60;&#x60; name &#x3D; my-kafka and cloud_provider &#x3D; aws &#x60;&#x60;&#x60;  To retrieve kafka request with its name starting with &#x60;my&#x60;, the value should be:  &#x60;&#x60;&#x60; name like my%25 &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the kafkas that the user has permission to see will be returned.  Note. If the query is invalid, an error will be returned 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKafkas: async (page?: string, size?: string, orderBy?: string, search?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/managed-services-api/v1/kafkas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List service accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceAccounts: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/managed-services-api/v1/serviceaccounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary reset credentials for the service account
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetServiceAccountCreds: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resetServiceAccountCreds', 'id', id)
            const localVarPath = `/api/managed-services-api/v1/serviceaccounts/{id}/reset-credentials`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the status of resources e.g whether we have reached maximum service capacity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceStatus: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/managed-services-api/v1/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the status of an agent cluster
         * @param {string} id The id of record
         * @param {DataPlaneClusterUpdateStatusRequest} dataPlaneClusterUpdateStatusRequest Cluster status update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAgentClusterStatus: async (id: string, dataPlaneClusterUpdateStatusRequest: DataPlaneClusterUpdateStatusRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAgentClusterStatus', 'id', id)
            // verify required parameter 'dataPlaneClusterUpdateStatusRequest' is not null or undefined
            assertParamExists('updateAgentClusterStatus', 'dataPlaneClusterUpdateStatusRequest', dataPlaneClusterUpdateStatusRequest)
            const localVarPath = `/api/managed-services-api/v1/agent-clusters/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataPlaneClusterUpdateStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the status of Kafka clusters on an agent cluster
         * @param {string} id The id of record
         * @param {{ [key: string]: DataPlaneKafkaStatus; }} requestBody Kafka clusters status update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKafkaClusterStatus: async (id: string, requestBody: { [key: string]: DataPlaneKafkaStatus; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateKafkaClusterStatus', 'id', id)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateKafkaClusterStatus', 'requestBody', requestBody)
            const localVarPath = `/api/managed-services-api/v1/agent-clusters/{id}/kafkas/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the status of a connector agent cluster
         * @param {string} id The id of record
         * @param {ConnectorClusterUpdateStatus} connectorClusterUpdateStatus Cluster status update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKafkaConnectorAgentClusterStatus: async (id: string, connectorClusterUpdateStatus: ConnectorClusterUpdateStatus, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateKafkaConnectorAgentClusterStatus', 'id', id)
            // verify required parameter 'connectorClusterUpdateStatus' is not null or undefined
            assertParamExists('updateKafkaConnectorAgentClusterStatus', 'connectorClusterUpdateStatus', connectorClusterUpdateStatus)
            const localVarPath = `/api/managed-services-api/v1/kafka-connector-clusters/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorClusterUpdateStatus, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the status of a connector agent cluster
         * @param {string} id The id of record
         * @param {string} cid The id of the connector
         * @param {ConnectorUpdateStatus} connectorUpdateStatus Cluster status update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKafkaConnectorStatus: async (id: string, cid: string, connectorUpdateStatus: ConnectorUpdateStatus, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateKafkaConnectorStatus', 'id', id)
            // verify required parameter 'cid' is not null or undefined
            assertParamExists('updateKafkaConnectorStatus', 'cid', cid)
            // verify required parameter 'connectorUpdateStatus' is not null or undefined
            assertParamExists('updateKafkaConnectorStatus', 'connectorUpdateStatus', connectorUpdateStatus)
            const localVarPath = `/api/managed-services-api/v1/kafka-connector-clusters/{id}/connectors/{cid}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorUpdateStatus, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the version metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionMetadata: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/managed-services-api/v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes the add-on. 
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsAddonIdDelete(addonId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsAddonIdDelete(addonId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the add-on. 
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsAddonIdGet(addonId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsAddonIdGet(addonId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the add-on. 
         * @param {string} addonId 
         * @param {AddOn} [addOn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsAddonIdPatch(addonId: string, addOn?: AddOn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsAddonIdPatch(addonId, addOn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of add-ons. 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-ons descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to retrieve all the add-ons with a name starting with &#x60;my&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-ons that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsGet(order?: string, page?: number, search?: string, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new add-on and add it to the collection of add-ons. 
         * @param {AddOn} [addOn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsPost(addOn?: AddOn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsPost(addOn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the aws infrastructure access role. 
         * @param {string} awsInfrastructureAccessRoleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet(awsInfrastructureAccessRoleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AWSInfrastructureAccessRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet(awsInfrastructureAccessRoleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to sort the roles descending by dislay_name the value should be:   &#x60;&#x60;&#x60; display_name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to retrieve all the role with a name starting with &#x60;my&#x60;the value should be:   &#x60;&#x60;&#x60; display_name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the roles that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AwsInfrastructureAccessRolesGet(order?: string, page?: number, search?: string, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AwsInfrastructureAccessRolesGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of available regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider. 
         * @param {string} cloudProviderId 
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;. 
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider. 
         * @param {AWS} [aWS] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost(cloudProviderId: string, page?: number, size?: number, aWS?: AWS, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost(cloudProviderId, page, size, aWS, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the cloud provider. 
         * @param {string} cloudProviderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1CloudProvidersCloudProviderIdGet(cloudProviderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudProvider1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1CloudProvidersCloudProviderIdGet(cloudProviderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of regions of the provider. 
         * @param {string} cloudProviderId 
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;. 
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet(cloudProviderId: string, page?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet(cloudProviderId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the region. 
         * @param {string} cloudProviderId 
         * @param {string} regionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet(cloudProviderId: string, regionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudRegion1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet(cloudProviderId, regionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of cloud providers. 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to sort the clusters descending by name identifier the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to retrieve all the cloud providers with a name starting with &#x60;A&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1CloudProvidersGet(order?: string, page?: number, search?: string, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1CloudProvidersGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an add-on installation and remove it from the collection of add-on installations on the cluster. 
         * @param {string} clusterId 
         * @param {string} addoninstallationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete(clusterId: string, addoninstallationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete(clusterId, addoninstallationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the add-on installation. 
         * @param {string} clusterId 
         * @param {string} addoninstallationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet(clusterId: string, addoninstallationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOnInstallation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet(clusterId, addoninstallationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the add-on installation. 
         * @param {string} clusterId 
         * @param {string} addoninstallationId 
         * @param {AddOnInstallation} [addOnInstallation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch(clusterId: string, addoninstallationId: string, addOnInstallation?: AddOnInstallation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOnInstallation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch(clusterId, addoninstallationId, addOnInstallation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of add-on installations. 
         * @param {string} clusterId 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to sort the add-on installations descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to retrieve all the add-on installations with a name starting with &#x60;my&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-on installations that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonsGet(clusterId: string, order?: string, page?: number, search?: string, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonsGet(clusterId, order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new add-on installation and add it to the collection of add-on installations on the cluster. 
         * @param {string} clusterId 
         * @param {AddOnInstallation} [addOnInstallation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonsPost(clusterId: string, addOnInstallation?: AddOnInstallation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOnInstallation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonsPost(clusterId, addOnInstallation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the AWS infrastructure access role grant. 
         * @param {string} clusterId 
         * @param {string} awsInfrastructureAccessRoleGrantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete(clusterId: string, awsInfrastructureAccessRoleGrantId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete(clusterId, awsInfrastructureAccessRoleGrantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the AWS infrastructure access role grant. 
         * @param {string} clusterId 
         * @param {string} awsInfrastructureAccessRoleGrantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet(clusterId: string, awsInfrastructureAccessRoleGrantId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AWSInfrastructureAccessRoleGrant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet(clusterId, awsInfrastructureAccessRoleGrantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of AWS infrastructure access role grants. 
         * @param {string} clusterId 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to sort the AWS infrastructure access role grants descending by user ARN the value should be:   &#x60;&#x60;&#x60; user_arn desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to retrieve all the AWS infrastructure access role grants with a user ARN starting with &#x60;user&#x60; the value should be:   &#x60;&#x60;&#x60; user_arn like \&#39;%user\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the AWS infrastructure access role grants that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet(clusterId: string, order?: string, page?: number, search?: string, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet(clusterId, order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new AWS infrastructure access role grant and add it to the collection of AWS infrastructure access role grants on the cluster. 
         * @param {string} clusterId 
         * @param {AWSInfrastructureAccessRoleGrant} [aWSInfrastructureAccessRoleGrant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost(clusterId: string, aWSInfrastructureAccessRoleGrant?: AWSInfrastructureAccessRoleGrant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AWSInfrastructureAccessRoleGrant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost(clusterId, aWSInfrastructureAccessRoleGrant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the credentials of a cluster. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdCredentialsGet(clusterId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdCredentialsGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the cluster. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdDelete(clusterId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdDelete(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the external configuration. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet(clusterId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of labels. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet(clusterId: string, page?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the label. 
         * @param {string} clusterId 
         * @param {string} labelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete(clusterId: string, labelId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete(clusterId, labelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the label. 
         * @param {string} clusterId 
         * @param {string} labelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet(clusterId: string, labelId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet(clusterId, labelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the label. 
         * @param {string} clusterId 
         * @param {string} labelId 
         * @param {Label} [label] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch(clusterId: string, labelId: string, label?: Label, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch(clusterId, labelId, label, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new label to the cluster. 
         * @param {string} clusterId 
         * @param {Label} [label] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost(clusterId: string, label?: Label, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost(clusterId, label, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of syncsets. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet(clusterId: string, page?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new syncset to the cluster. 
         * @param {string} clusterId 
         * @param {Syncset} [syncset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost(clusterId: string, syncset?: Syncset, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Syncset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost(clusterId, syncset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the syncset. 
         * @param {string} clusterId 
         * @param {string} syncsetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete(clusterId: string, syncsetId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete(clusterId, syncsetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the syncset. 
         * @param {string} clusterId 
         * @param {string} syncsetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet(clusterId: string, syncsetId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Syncset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet(clusterId, syncsetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the syncset. 
         * @param {string} clusterId 
         * @param {string} syncsetId 
         * @param {Syncset} [syncset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch(clusterId: string, syncsetId: string, syncset?: Syncset, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Syncset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch(clusterId, syncsetId, syncset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the cluster. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGet(clusterId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of groups. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGroupsGet(clusterId: string, page?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20010>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGroupsGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the group. 
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet(clusterId: string, groupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet(clusterId, groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of users. 
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet(clusterId: string, groupId: string, page?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet(clusterId, groupId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new user to the group. 
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost(clusterId: string, groupId: string, user?: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost(clusterId, groupId, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the user. 
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete(clusterId: string, groupId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete(clusterId, groupId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the user. 
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet(clusterId: string, groupId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet(clusterId, groupId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initiates cluster hibernation. While hibernating a cluster will not consume any cloud provider infrastructure but will be counted for quota. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdHibernatePost(clusterId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdHibernatePost(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of identity providers. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet(clusterId: string, page?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the identity provider. 
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete(clusterId: string, identityProviderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete(clusterId, identityProviderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the identity provider. 
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet(clusterId: string, identityProviderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProvider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet(clusterId, identityProviderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update identity provider in the cluster. 
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {IdentityProvider} [identityProvider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch(clusterId: string, identityProviderId: string, identityProvider?: IdentityProvider, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProvider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch(clusterId, identityProviderId, identityProvider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new identity provider to the cluster. 
         * @param {string} clusterId 
         * @param {IdentityProvider} [identityProvider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost(clusterId: string, identityProvider?: IdentityProvider, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProvider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost(clusterId, identityProvider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of ingresses. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIngressesGet(clusterId: string, page?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIngressesGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the ingress. 
         * @param {string} clusterId 
         * @param {string} ingressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete(clusterId: string, ingressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete(clusterId, ingressId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the ingress. 
         * @param {string} clusterId 
         * @param {string} ingressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet(clusterId: string, ingressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet(clusterId, ingressId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the ingress. 
         * @param {string} clusterId 
         * @param {string} ingressId 
         * @param {Ingress} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch(clusterId: string, ingressId: string, ingress?: Ingress, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch(clusterId, ingressId, ingress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates all ingresses 
         * @param {string} clusterId 
         * @param {Array<Ingress>} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIngressesPatch(clusterId: string, ingress?: Array<Ingress>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ingress>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIngressesPatch(clusterId, ingress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new ingress to the cluster. 
         * @param {string} clusterId 
         * @param {Ingress} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIngressesPost(clusterId: string, ingress?: Ingress, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIngressesPost(clusterId, ingress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of log links. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdLogsGet(clusterId: string, page?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdLogsGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the log. 
         * @param {string} clusterId 
         * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log. 
         * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdLogsInstallGet(clusterId: string, offset?: number, tail?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Log>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdLogsInstallGet(clusterId, offset, tail, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the log. 
         * @param {string} clusterId 
         * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log. 
         * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdLogsUninstallGet(clusterId: string, offset?: number, tail?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Log>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdLogsUninstallGet(clusterId, offset, tail, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of machine pools. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMachinePoolsGet(clusterId: string, page?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMachinePoolsGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the machine pool. 
         * @param {string} clusterId 
         * @param {string} machinePoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete(clusterId: string, machinePoolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete(clusterId, machinePoolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the machine pool. 
         * @param {string} clusterId 
         * @param {string} machinePoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet(clusterId: string, machinePoolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachinePool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet(clusterId, machinePoolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the machine pool. 
         * @param {string} clusterId 
         * @param {string} machinePoolId 
         * @param {MachinePool} [machinePool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch(clusterId: string, machinePoolId: string, machinePool?: MachinePool, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachinePool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch(clusterId, machinePoolId, machinePool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new machine pool to the cluster. 
         * @param {string} clusterId 
         * @param {MachinePool} [machinePool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMachinePoolsPost(clusterId: string, machinePool?: MachinePool, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachinePool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMachinePoolsPost(clusterId, machinePool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet(clusterId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertsInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet(clusterId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterOperatorsInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the metrics. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet(clusterId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CPUTotalsNodeRoleOSMetricNode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet(clusterId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodesInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the metrics. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet(clusterId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SocketTotalsNodeRoleOSMetricNode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the cluster. 
         * @param {string} clusterId 
         * @param {Cluster} [cluster] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdPatch(clusterId: string, cluster?: Cluster, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdPatch(clusterId, cluster, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the product. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdProductGet(clusterId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdProductGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the provision shard. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdProvisionShardGet(clusterId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisionShard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdProvisionShardGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resumes from Hibernation. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdResumePost(clusterId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdResumePost(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdStatusGet(clusterId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdStatusGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of upgrade policies. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet(clusterId: string, page?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new upgrade policy to the cluster. 
         * @param {string} clusterId 
         * @param {UpgradePolicy} [upgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost(clusterId: string, upgradePolicy?: UpgradePolicy, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpgradePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost(clusterId, upgradePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the upgrade policy. 
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete(clusterId: string, upgradePolicyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete(clusterId, upgradePolicyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the upgrade policy. 
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet(clusterId: string, upgradePolicyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpgradePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet(clusterId, upgradePolicyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the upgrade policy. 
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {UpgradePolicy} [upgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch(clusterId: string, upgradePolicyId: string, upgradePolicy?: UpgradePolicy, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpgradePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch(clusterId, upgradePolicyId, upgradePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the upgrade policy state. 
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet(clusterId: string, upgradePolicyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpgradePolicyState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet(clusterId, upgradePolicyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the upgrade policy state. 
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {UpgradePolicyState} [upgradePolicyState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch(clusterId: string, upgradePolicyId: string, upgradePolicyState?: UpgradePolicyState, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpgradePolicyState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch(clusterId, upgradePolicyId, upgradePolicyState, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of clusters. 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to sort the clusters descending by region identifier the value should be:   &#x60;&#x60;&#x60; region.id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to retrieve all the clusters with a name starting with &#x60;my&#x60; in the &#x60;us-east-1&#x60; region the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; and region.id &#x3D; \&#39;us-east-1\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersGet(order?: string, page?: number, search?: string, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provision a new cluster and add it to the collection of clusters.  See the `register_cluster` method for adding an existing cluster. 
         * @param {Cluster} [cluster] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersPost(cluster?: Cluster, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersPost(cluster, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the dashboard. 
         * @param {string} dashboardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1DashboardsDashboardIdGet(dashboardId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1DashboardsDashboardIdGet(dashboardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of dashboards. 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the dashboard instead of the names of the columns of a table. For example, in order to sort the dashboards descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the dashboard instead of the names of the columns of a table. For example, in order to retrieve all the dashboards with a name starting with &#x60;my&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the dashboards that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1DashboardsGet(order?: string, page?: number, search?: string, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1DashboardsGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the cluster flavour. 
         * @param {string} flavourId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1FlavoursFlavourIdGet(flavourId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flavour>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1FlavoursFlavourIdGet(flavourId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the flavour.  Attributes that can be updated are:  - `aws.infra_volume` - `aws.infra_instance_type` - `gcp.infra_instance_type` 
         * @param {string} flavourId 
         * @param {Flavour} [flavour] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1FlavoursFlavourIdPatch(flavourId: string, flavour?: Flavour, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flavour>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1FlavoursFlavourIdPatch(flavourId, flavour, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to sort the flavours descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to retrieve all the flavours with a name starting with &#x60;my&#x60;the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the flavours that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1FlavoursGet(order?: string, page?: number, search?: string, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20018>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1FlavoursGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new cluster flavour. 
         * @param {Flavour} [flavour] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1FlavoursPost(flavour?: Flavour, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flavour>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1FlavoursPost(flavour, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the version metadata. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1Get(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1Get(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of machine types. 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to sort the machine types descending by name identifier the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to retrieve all the machine types with a name starting with &#x60;A&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the machine types that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1MachineTypesGet(order?: string, page?: number, search?: string, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20019>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1MachineTypesGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of products. 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to sort the products descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to retrieve all the products with a name starting with &#x60;my&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the products that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ProductsGet(order?: string, page?: number, search?: string, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20020>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ProductsGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the product. 
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ProductsProductIdGet(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ProductsProductIdGet(productId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ProvisionShardsGet(page?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20021>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ProvisionShardsGet(page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the provision shard. 
         * @param {string} provisionShardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ProvisionShardsProvisionShardIdGet(provisionShardId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisionShard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ProvisionShardsProvisionShardIdGet(provisionShardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of versions. 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to sort the versions descending by identifier the value should be:   &#x60;&#x60;&#x60; id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to retrieve all the versions that are enabled:   &#x60;&#x60;&#x60; enabled &#x3D; \&#39;t\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the versions that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page.  Default value is &#x60;100&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1VersionsGet(order?: string, page?: number, search?: string, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1VersionsGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the version. 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1VersionsVersionIdGet(versionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Version>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1VersionsVersionIdGet(versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new connector
         * @param {string} id The id of record
         * @param {boolean} async Perform the action in an asynchronous manner
         * @param {Connector} connector Connector data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnector(id: string, async: boolean, connector: Connector, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnector(id, async, connector, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new connector cluster
         * @param {string} id The id of record
         * @param {boolean} async Perform the action in an asynchronous manner
         * @param {ConnectorCluster} connectorCluster Connector cluster data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnectorCluster(id: string, async: boolean, connectorCluster: ConnectorCluster, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorCluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnectorCluster(id, async, connectorCluster, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new kafka Request
         * @param {boolean} async Perform the action in an asynchronous manner
         * @param {KafkaRequestPayload} kafkaRequestPayload Kafka data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKafka(async: boolean, kafkaRequestPayload: KafkaRequestPayload, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KafkaRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKafka(async, kafkaRequestPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a service account
         * @param {ServiceAccountRequest} serviceAccountRequest service account request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceAccount(serviceAccountRequest: ServiceAccountRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServiceAccount(serviceAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a connector
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConnector(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Error>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConnector(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a connector cluster
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConnectorCluster(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Error>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConnectorCluster(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a kafka request by id
         * @param {string} id The id of record
         * @param {boolean} async Perform the action in an asynchronous manner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKafkaById(id: string, async: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Error>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKafkaById(id, async, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete service account
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServiceAccount(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Error>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServiceAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a connector deployment
         * @param {string} id The id of record
         * @param {string} cid The id of the connector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnector(id: string, cid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnector(id, cid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a connector cluster
         * @param {string} id The id of record
         * @param {string} cid The id of the connector cluster
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectorCluster(id: string, cid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorCluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectorCluster(id, cid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a connector cluster\'s addon parameters
         * @param {string} id The id of record
         * @param {string} cid The id of the connector cluster
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectorClusterAddonParameters(id: string, cid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AddonParameter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectorClusterAddonParameters(id, cid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a connector type by name and version
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectorTypeByID(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectorTypeByID(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the spec of the ManagedKafkaAgent CR spec
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKafkaAgent(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataplaneClusterAgentConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKafkaAgent(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a kafka request by id
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKafkaById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KafkaRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKafkaById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the list of ManagedaKafkas for the specified agent cluster
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKafkas(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedKafkaList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKafkas(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get metrics with instant query by kafka id.
         * @param {string} id The id of record
         * @param {Array<string>} [filters] List of metrics to fetch. Fetch all metrics when empty. List entries are kafka internal metric names.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetricsByInstantQuery(id: string, filters?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsInstantQueryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetricsByInstantQuery(id, filters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get metrics with timeseries range query by kafka id.
         * @param {string} id The id of record
         * @param {number} duration The length of time in minutes over which to return the metrics.
         * @param {number} interval The interval in seconds between data points.
         * @param {Array<string>} [filters] List of metrics to fetch. Fetch all metrics when empty. List entries are kafka internal metric names.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetricsByRangeQuery(id: string, duration: number, interval: number, filters?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsRangeQueryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetricsByRangeQuery(id, duration, interval, filters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get service account by id
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceAccountById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceAccountById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves the list of supported regions of the supported cloud provider.
         * @param {string} id The id of record
         * @param {string} [page] Page index
         * @param {string} [size] Number of items in each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCloudProviderRegions(id: string, page?: string, size?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudRegionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCloudProviderRegions(id, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves the list of supported cloud providers.
         * @param {string} [page] Page index
         * @param {string} [size] Number of items in each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCloudProviders(page?: string, size?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudProviderList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCloudProviders(page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of connector types
         * @param {string} id The id of record
         * @param {string} [page] Page index
         * @param {string} [size] Number of items in each page
         * @param {number} [gtVersion] filters the connectors to those with a version greater than the given value
         * @param {boolean} [watch] watch for changes to the resources and return them as a stream of watch events. Specify gt_version to specify the starting point.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClusterAsignedConnectors(id: string, page?: string, size?: string, gtVersion?: number, watch?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClusterAsignedConnectors(id, page, size, gtVersion, watch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of connector clusters
         * @param {string} id The id of record
         * @param {string} [page] Page index
         * @param {string} [size] Number of items in each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConnectorClusters(id: string, page?: string, size?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorClusterList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnectorClusters(id, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of connector types
         * @param {string} [page] Page index
         * @param {string} [size] Number of items in each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConnectorTypes(page?: string, size?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorTypeList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnectorTypes(page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of connector types
         * @param {string} id The id of record
         * @param {string} [page] Page index
         * @param {string} [size] Number of items in each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConnectors(id: string, page?: string, size?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnectors(id, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of Kafka requests
         * @param {string} [page] Page index
         * @param {string} [size] Number of items in each page
         * @param {string} [orderBy] Specifies the order by criteria. The syntax of this parameter is similar to the syntax of the _order by_ clause of an SQL statement. Each query can be ordered by any of the kafkaRequests fields. For example, in order to retrieve all kafkas ordered by their name:  &#x60;&#x60;&#x60;sql name asc &#x60;&#x60;&#x60;  Or in order to retrieve all kafkas ordered by their name _and_ created date:  &#x60;&#x60;&#x60;sql name asc, created_at asc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the results will be ordered by name.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement. Allowed fields in the search are: cloud_provider, name, owner, region and status. Allowed comparators are &#x60;&lt;&gt;&#x60;, &#x60;&#x3D;&#x60; or &#x60;LIKE&#x60;. Allowed joins are &#x60;AND&#x60; and &#x60;OR&#x60;, however there is a limit of max 10 joins in the search query.  Examples:  To retrieve kafka request with name equal &#x60;my-kafka&#x60; and region equal &#x60;aws&#x60;, the value should be:  &#x60;&#x60;&#x60; name &#x3D; my-kafka and cloud_provider &#x3D; aws &#x60;&#x60;&#x60;  To retrieve kafka request with its name starting with &#x60;my&#x60;, the value should be:  &#x60;&#x60;&#x60; name like my%25 &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the kafkas that the user has permission to see will be returned.  Note. If the query is invalid, an error will be returned 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKafkas(page?: string, size?: string, orderBy?: string, search?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KafkaRequestList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKafkas(page, size, orderBy, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List service accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServiceAccounts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceAccountList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listServiceAccounts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary reset credentials for the service account
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetServiceAccountCreds(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetServiceAccountCreds(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves the status of resources e.g whether we have reached maximum service capacity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceStatus(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the status of an agent cluster
         * @param {string} id The id of record
         * @param {DataPlaneClusterUpdateStatusRequest} dataPlaneClusterUpdateStatusRequest Cluster status update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAgentClusterStatus(id: string, dataPlaneClusterUpdateStatusRequest: DataPlaneClusterUpdateStatusRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAgentClusterStatus(id, dataPlaneClusterUpdateStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the status of Kafka clusters on an agent cluster
         * @param {string} id The id of record
         * @param {{ [key: string]: DataPlaneKafkaStatus; }} requestBody Kafka clusters status update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKafkaClusterStatus(id: string, requestBody: { [key: string]: DataPlaneKafkaStatus; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKafkaClusterStatus(id, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the status of a connector agent cluster
         * @param {string} id The id of record
         * @param {ConnectorClusterUpdateStatus} connectorClusterUpdateStatus Cluster status update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKafkaConnectorAgentClusterStatus(id: string, connectorClusterUpdateStatus: ConnectorClusterUpdateStatus, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKafkaConnectorAgentClusterStatus(id, connectorClusterUpdateStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the status of a connector agent cluster
         * @param {string} id The id of record
         * @param {string} cid The id of the connector
         * @param {ConnectorUpdateStatus} connectorUpdateStatus Cluster status update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKafkaConnectorStatus(id: string, cid: string, connectorUpdateStatus: ConnectorUpdateStatus, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKafkaConnectorStatus(id, cid, connectorUpdateStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves the version metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async versionMetadata(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.versionMetadata(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Deletes the add-on. 
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdDelete(addonId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1AddonsAddonIdDelete(addonId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the add-on. 
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdGet(addonId: string, options?: any): AxiosPromise<AddOn> {
            return localVarFp.apiClustersMgmtV1AddonsAddonIdGet(addonId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the add-on. 
         * @param {string} addonId 
         * @param {AddOn} [addOn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdPatch(addonId: string, addOn?: AddOn, options?: any): AxiosPromise<AddOn> {
            return localVarFp.apiClustersMgmtV1AddonsAddonIdPatch(addonId, addOn, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of add-ons. 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-ons descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to retrieve all the add-ons with a name starting with &#x60;my&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-ons that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.apiClustersMgmtV1AddonsGet(order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new add-on and add it to the collection of add-ons. 
         * @param {AddOn} [addOn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsPost(addOn?: AddOn, options?: any): AxiosPromise<AddOn> {
            return localVarFp.apiClustersMgmtV1AddonsPost(addOn, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the aws infrastructure access role. 
         * @param {string} awsInfrastructureAccessRoleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet(awsInfrastructureAccessRoleId: string, options?: any): AxiosPromise<AWSInfrastructureAccessRole> {
            return localVarFp.apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet(awsInfrastructureAccessRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to sort the roles descending by dislay_name the value should be:   &#x60;&#x60;&#x60; display_name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to retrieve all the role with a name starting with &#x60;my&#x60;the value should be:   &#x60;&#x60;&#x60; display_name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the roles that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInfrastructureAccessRolesGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.apiClustersMgmtV1AwsInfrastructureAccessRolesGet(order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of available regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider. 
         * @param {string} cloudProviderId 
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;. 
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider. 
         * @param {AWS} [aWS] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost(cloudProviderId: string, page?: number, size?: number, aWS?: AWS, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost(cloudProviderId, page, size, aWS, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the cloud provider. 
         * @param {string} cloudProviderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdGet(cloudProviderId: string, options?: any): AxiosPromise<CloudProvider1> {
            return localVarFp.apiClustersMgmtV1CloudProvidersCloudProviderIdGet(cloudProviderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of regions of the provider. 
         * @param {string} cloudProviderId 
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;. 
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet(cloudProviderId: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet(cloudProviderId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the region. 
         * @param {string} cloudProviderId 
         * @param {string} regionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet(cloudProviderId: string, regionId: string, options?: any): AxiosPromise<CloudRegion1> {
            return localVarFp.apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet(cloudProviderId, regionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of cloud providers. 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to sort the clusters descending by name identifier the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to retrieve all the cloud providers with a name starting with &#x60;A&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.apiClustersMgmtV1CloudProvidersGet(order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an add-on installation and remove it from the collection of add-on installations on the cluster. 
         * @param {string} clusterId 
         * @param {string} addoninstallationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete(clusterId: string, addoninstallationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete(clusterId, addoninstallationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the add-on installation. 
         * @param {string} clusterId 
         * @param {string} addoninstallationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet(clusterId: string, addoninstallationId: string, options?: any): AxiosPromise<AddOnInstallation> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet(clusterId, addoninstallationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the add-on installation. 
         * @param {string} clusterId 
         * @param {string} addoninstallationId 
         * @param {AddOnInstallation} [addOnInstallation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch(clusterId: string, addoninstallationId: string, addOnInstallation?: AddOnInstallation, options?: any): AxiosPromise<AddOnInstallation> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch(clusterId, addoninstallationId, addOnInstallation, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of add-on installations. 
         * @param {string} clusterId 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to sort the add-on installations descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to retrieve all the add-on installations with a name starting with &#x60;my&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-on installations that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsGet(clusterId: string, order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonsGet(clusterId, order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new add-on installation and add it to the collection of add-on installations on the cluster. 
         * @param {string} clusterId 
         * @param {AddOnInstallation} [addOnInstallation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsPost(clusterId: string, addOnInstallation?: AddOnInstallation, options?: any): AxiosPromise<AddOnInstallation> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonsPost(clusterId, addOnInstallation, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the AWS infrastructure access role grant. 
         * @param {string} clusterId 
         * @param {string} awsInfrastructureAccessRoleGrantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete(clusterId: string, awsInfrastructureAccessRoleGrantId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete(clusterId, awsInfrastructureAccessRoleGrantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the AWS infrastructure access role grant. 
         * @param {string} clusterId 
         * @param {string} awsInfrastructureAccessRoleGrantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet(clusterId: string, awsInfrastructureAccessRoleGrantId: string, options?: any): AxiosPromise<AWSInfrastructureAccessRoleGrant> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet(clusterId, awsInfrastructureAccessRoleGrantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of AWS infrastructure access role grants. 
         * @param {string} clusterId 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to sort the AWS infrastructure access role grants descending by user ARN the value should be:   &#x60;&#x60;&#x60; user_arn desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to retrieve all the AWS infrastructure access role grants with a user ARN starting with &#x60;user&#x60; the value should be:   &#x60;&#x60;&#x60; user_arn like \&#39;%user\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the AWS infrastructure access role grants that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet(clusterId: string, order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse2007> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet(clusterId, order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new AWS infrastructure access role grant and add it to the collection of AWS infrastructure access role grants on the cluster. 
         * @param {string} clusterId 
         * @param {AWSInfrastructureAccessRoleGrant} [aWSInfrastructureAccessRoleGrant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost(clusterId: string, aWSInfrastructureAccessRoleGrant?: AWSInfrastructureAccessRoleGrant, options?: any): AxiosPromise<AWSInfrastructureAccessRoleGrant> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost(clusterId, aWSInfrastructureAccessRoleGrant, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the credentials of a cluster. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdCredentialsGet(clusterId: string, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdCredentialsGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the cluster. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdDelete(clusterId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdDelete(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the external configuration. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet(clusterId: string, options?: any): AxiosPromise<ExternalConfiguration> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of labels. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet(clusterId: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse2008> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet(clusterId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the label. 
         * @param {string} clusterId 
         * @param {string} labelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete(clusterId: string, labelId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete(clusterId, labelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the label. 
         * @param {string} clusterId 
         * @param {string} labelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet(clusterId: string, labelId: string, options?: any): AxiosPromise<Label> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet(clusterId, labelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the label. 
         * @param {string} clusterId 
         * @param {string} labelId 
         * @param {Label} [label] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch(clusterId: string, labelId: string, label?: Label, options?: any): AxiosPromise<Label> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch(clusterId, labelId, label, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new label to the cluster. 
         * @param {string} clusterId 
         * @param {Label} [label] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost(clusterId: string, label?: Label, options?: any): AxiosPromise<Label> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost(clusterId, label, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of syncsets. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet(clusterId: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse2009> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet(clusterId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new syncset to the cluster. 
         * @param {string} clusterId 
         * @param {Syncset} [syncset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost(clusterId: string, syncset?: Syncset, options?: any): AxiosPromise<Syncset> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost(clusterId, syncset, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the syncset. 
         * @param {string} clusterId 
         * @param {string} syncsetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete(clusterId: string, syncsetId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete(clusterId, syncsetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the syncset. 
         * @param {string} clusterId 
         * @param {string} syncsetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet(clusterId: string, syncsetId: string, options?: any): AxiosPromise<Syncset> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet(clusterId, syncsetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the syncset. 
         * @param {string} clusterId 
         * @param {string} syncsetId 
         * @param {Syncset} [syncset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch(clusterId: string, syncsetId: string, syncset?: Syncset, options?: any): AxiosPromise<Syncset> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch(clusterId, syncsetId, syncset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the cluster. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGet(clusterId: string, options?: any): AxiosPromise<Cluster> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of groups. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGet(clusterId: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20010> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGroupsGet(clusterId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the group. 
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet(clusterId: string, groupId: string, options?: any): AxiosPromise<Group> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet(clusterId, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of users. 
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet(clusterId: string, groupId: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20011> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet(clusterId, groupId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new user to the group. 
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost(clusterId: string, groupId: string, user?: User, options?: any): AxiosPromise<User> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost(clusterId, groupId, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the user. 
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete(clusterId: string, groupId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete(clusterId, groupId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the user. 
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet(clusterId: string, groupId: string, userId: string, options?: any): AxiosPromise<User> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet(clusterId, groupId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates cluster hibernation. While hibernating a cluster will not consume any cloud provider infrastructure but will be counted for quota. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdHibernatePost(clusterId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdHibernatePost(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of identity providers. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet(clusterId: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20012> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet(clusterId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the identity provider. 
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete(clusterId: string, identityProviderId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete(clusterId, identityProviderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the identity provider. 
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet(clusterId: string, identityProviderId: string, options?: any): AxiosPromise<IdentityProvider> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet(clusterId, identityProviderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update identity provider in the cluster. 
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {IdentityProvider} [identityProvider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch(clusterId: string, identityProviderId: string, identityProvider?: IdentityProvider, options?: any): AxiosPromise<IdentityProvider> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch(clusterId, identityProviderId, identityProvider, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new identity provider to the cluster. 
         * @param {string} clusterId 
         * @param {IdentityProvider} [identityProvider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost(clusterId: string, identityProvider?: IdentityProvider, options?: any): AxiosPromise<IdentityProvider> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost(clusterId, identityProvider, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of ingresses. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesGet(clusterId: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIngressesGet(clusterId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the ingress. 
         * @param {string} clusterId 
         * @param {string} ingressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete(clusterId: string, ingressId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete(clusterId, ingressId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the ingress. 
         * @param {string} clusterId 
         * @param {string} ingressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet(clusterId: string, ingressId: string, options?: any): AxiosPromise<Ingress> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet(clusterId, ingressId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the ingress. 
         * @param {string} clusterId 
         * @param {string} ingressId 
         * @param {Ingress} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch(clusterId: string, ingressId: string, ingress?: Ingress, options?: any): AxiosPromise<Ingress> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch(clusterId, ingressId, ingress, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates all ingresses 
         * @param {string} clusterId 
         * @param {Array<Ingress>} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesPatch(clusterId: string, ingress?: Array<Ingress>, options?: any): AxiosPromise<Array<Ingress>> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIngressesPatch(clusterId, ingress, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new ingress to the cluster. 
         * @param {string} clusterId 
         * @param {Ingress} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesPost(clusterId: string, ingress?: Ingress, options?: any): AxiosPromise<Ingress> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIngressesPost(clusterId, ingress, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of log links. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLogsGet(clusterId: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdLogsGet(clusterId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the log. 
         * @param {string} clusterId 
         * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log. 
         * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLogsInstallGet(clusterId: string, offset?: number, tail?: number, options?: any): AxiosPromise<Log> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdLogsInstallGet(clusterId, offset, tail, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the log. 
         * @param {string} clusterId 
         * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log. 
         * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLogsUninstallGet(clusterId: string, offset?: number, tail?: number, options?: any): AxiosPromise<Log> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdLogsUninstallGet(clusterId, offset, tail, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of machine pools. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsGet(clusterId: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20015> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMachinePoolsGet(clusterId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the machine pool. 
         * @param {string} clusterId 
         * @param {string} machinePoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete(clusterId: string, machinePoolId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete(clusterId, machinePoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the machine pool. 
         * @param {string} clusterId 
         * @param {string} machinePoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet(clusterId: string, machinePoolId: string, options?: any): AxiosPromise<MachinePool> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet(clusterId, machinePoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the machine pool. 
         * @param {string} clusterId 
         * @param {string} machinePoolId 
         * @param {MachinePool} [machinePool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch(clusterId: string, machinePoolId: string, machinePool?: MachinePool, options?: any): AxiosPromise<MachinePool> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch(clusterId, machinePoolId, machinePool, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new machine pool to the cluster. 
         * @param {string} clusterId 
         * @param {MachinePool} [machinePool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsPost(clusterId: string, machinePool?: MachinePool, options?: any): AxiosPromise<MachinePool> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMachinePoolsPost(clusterId, machinePool, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet(clusterId: string, options?: any): AxiosPromise<AlertsInfo> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet(clusterId: string, options?: any): AxiosPromise<ClusterOperatorsInfo> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the metrics. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet(clusterId: string, options?: any): AxiosPromise<CPUTotalsNodeRoleOSMetricNode> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet(clusterId: string, options?: any): AxiosPromise<NodesInfo> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the metrics. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet(clusterId: string, options?: any): AxiosPromise<SocketTotalsNodeRoleOSMetricNode> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the cluster. 
         * @param {string} clusterId 
         * @param {Cluster} [cluster] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdPatch(clusterId: string, cluster?: Cluster, options?: any): AxiosPromise<Cluster> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdPatch(clusterId, cluster, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the product. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdProductGet(clusterId: string, options?: any): AxiosPromise<Product> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdProductGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the provision shard. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdProvisionShardGet(clusterId: string, options?: any): AxiosPromise<ProvisionShard> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdProvisionShardGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Resumes from Hibernation. 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdResumePost(clusterId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdResumePost(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdStatusGet(clusterId: string, options?: any): AxiosPromise<ClusterStatus> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdStatusGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of upgrade policies. 
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Number of items contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet(clusterId: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20016> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet(clusterId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new upgrade policy to the cluster. 
         * @param {string} clusterId 
         * @param {UpgradePolicy} [upgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost(clusterId: string, upgradePolicy?: UpgradePolicy, options?: any): AxiosPromise<UpgradePolicy> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost(clusterId, upgradePolicy, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the upgrade policy. 
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete(clusterId: string, upgradePolicyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete(clusterId, upgradePolicyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the upgrade policy. 
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet(clusterId: string, upgradePolicyId: string, options?: any): AxiosPromise<UpgradePolicy> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet(clusterId, upgradePolicyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the upgrade policy. 
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {UpgradePolicy} [upgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch(clusterId: string, upgradePolicyId: string, upgradePolicy?: UpgradePolicy, options?: any): AxiosPromise<UpgradePolicy> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch(clusterId, upgradePolicyId, upgradePolicy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the upgrade policy state. 
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet(clusterId: string, upgradePolicyId: string, options?: any): AxiosPromise<UpgradePolicyState> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet(clusterId, upgradePolicyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the upgrade policy state. 
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {UpgradePolicyState} [upgradePolicyState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch(clusterId: string, upgradePolicyId: string, upgradePolicyState?: UpgradePolicyState, options?: any): AxiosPromise<UpgradePolicyState> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch(clusterId, upgradePolicyId, upgradePolicyState, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of clusters. 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to sort the clusters descending by region identifier the value should be:   &#x60;&#x60;&#x60; region.id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to retrieve all the clusters with a name starting with &#x60;my&#x60; in the &#x60;us-east-1&#x60; region the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; and region.id &#x3D; \&#39;us-east-1\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.apiClustersMgmtV1ClustersGet(order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Provision a new cluster and add it to the collection of clusters.  See the `register_cluster` method for adding an existing cluster. 
         * @param {Cluster} [cluster] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersPost(cluster?: Cluster, options?: any): AxiosPromise<Cluster> {
            return localVarFp.apiClustersMgmtV1ClustersPost(cluster, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the dashboard. 
         * @param {string} dashboardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1DashboardsDashboardIdGet(dashboardId: string, options?: any): AxiosPromise<Dashboard> {
            return localVarFp.apiClustersMgmtV1DashboardsDashboardIdGet(dashboardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of dashboards. 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the dashboard instead of the names of the columns of a table. For example, in order to sort the dashboards descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the dashboard instead of the names of the columns of a table. For example, in order to retrieve all the dashboards with a name starting with &#x60;my&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the dashboards that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1DashboardsGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse20017> {
            return localVarFp.apiClustersMgmtV1DashboardsGet(order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the cluster flavour. 
         * @param {string} flavourId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursFlavourIdGet(flavourId: string, options?: any): AxiosPromise<Flavour> {
            return localVarFp.apiClustersMgmtV1FlavoursFlavourIdGet(flavourId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the flavour.  Attributes that can be updated are:  - `aws.infra_volume` - `aws.infra_instance_type` - `gcp.infra_instance_type` 
         * @param {string} flavourId 
         * @param {Flavour} [flavour] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursFlavourIdPatch(flavourId: string, flavour?: Flavour, options?: any): AxiosPromise<Flavour> {
            return localVarFp.apiClustersMgmtV1FlavoursFlavourIdPatch(flavourId, flavour, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to sort the flavours descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to retrieve all the flavours with a name starting with &#x60;my&#x60;the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the flavours that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse20018> {
            return localVarFp.apiClustersMgmtV1FlavoursGet(order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new cluster flavour. 
         * @param {Flavour} [flavour] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursPost(flavour?: Flavour, options?: any): AxiosPromise<Flavour> {
            return localVarFp.apiClustersMgmtV1FlavoursPost(flavour, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the version metadata. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1Get(options?: any): AxiosPromise<Metadata> {
            return localVarFp.apiClustersMgmtV1Get(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of machine types. 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to sort the machine types descending by name identifier the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to retrieve all the machine types with a name starting with &#x60;A&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the machine types that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1MachineTypesGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse20019> {
            return localVarFp.apiClustersMgmtV1MachineTypesGet(order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of products. 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to sort the products descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to retrieve all the products with a name starting with &#x60;my&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the products that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProductsGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse20020> {
            return localVarFp.apiClustersMgmtV1ProductsGet(order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the product. 
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProductsProductIdGet(productId: string, options?: any): AxiosPromise<Product> {
            return localVarFp.apiClustersMgmtV1ProductsProductIdGet(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProvisionShardsGet(page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20021> {
            return localVarFp.apiClustersMgmtV1ProvisionShardsGet(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the provision shard. 
         * @param {string} provisionShardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProvisionShardsProvisionShardIdGet(provisionShardId: string, options?: any): AxiosPromise<ProvisionShard> {
            return localVarFp.apiClustersMgmtV1ProvisionShardsProvisionShardIdGet(provisionShardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of versions. 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to sort the versions descending by identifier the value should be:   &#x60;&#x60;&#x60; id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to retrieve all the versions that are enabled:   &#x60;&#x60;&#x60; enabled &#x3D; \&#39;t\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the versions that the user has permission to see will be returned. 
         * @param {number} [size] Maximum number of items that will be contained in the returned page.  Default value is &#x60;100&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionsGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse20022> {
            return localVarFp.apiClustersMgmtV1VersionsGet(order, page, search, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the version. 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionsVersionIdGet(versionId: string, options?: any): AxiosPromise<Version> {
            return localVarFp.apiClustersMgmtV1VersionsVersionIdGet(versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new connector
         * @param {string} id The id of record
         * @param {boolean} async Perform the action in an asynchronous manner
         * @param {Connector} connector Connector data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnector(id: string, async: boolean, connector: Connector, options?: any): AxiosPromise<Connector> {
            return localVarFp.createConnector(id, async, connector, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new connector cluster
         * @param {string} id The id of record
         * @param {boolean} async Perform the action in an asynchronous manner
         * @param {ConnectorCluster} connectorCluster Connector cluster data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectorCluster(id: string, async: boolean, connectorCluster: ConnectorCluster, options?: any): AxiosPromise<ConnectorCluster> {
            return localVarFp.createConnectorCluster(id, async, connectorCluster, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new kafka Request
         * @param {boolean} async Perform the action in an asynchronous manner
         * @param {KafkaRequestPayload} kafkaRequestPayload Kafka data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKafka(async: boolean, kafkaRequestPayload: KafkaRequestPayload, options?: any): AxiosPromise<KafkaRequest> {
            return localVarFp.createKafka(async, kafkaRequestPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a service account
         * @param {ServiceAccountRequest} serviceAccountRequest service account request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAccount(serviceAccountRequest: ServiceAccountRequest, options?: any): AxiosPromise<ServiceAccount> {
            return localVarFp.createServiceAccount(serviceAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a connector
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnector(id: string, options?: any): AxiosPromise<Error> {
            return localVarFp.deleteConnector(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a connector cluster
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnectorCluster(id: string, options?: any): AxiosPromise<Error> {
            return localVarFp.deleteConnectorCluster(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a kafka request by id
         * @param {string} id The id of record
         * @param {boolean} async Perform the action in an asynchronous manner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKafkaById(id: string, async: boolean, options?: any): AxiosPromise<Error> {
            return localVarFp.deleteKafkaById(id, async, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete service account
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAccount(id: string, options?: any): AxiosPromise<Error> {
            return localVarFp.deleteServiceAccount(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a connector deployment
         * @param {string} id The id of record
         * @param {string} cid The id of the connector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnector(id: string, cid: string, options?: any): AxiosPromise<Connector> {
            return localVarFp.getConnector(id, cid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a connector cluster
         * @param {string} id The id of record
         * @param {string} cid The id of the connector cluster
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorCluster(id: string, cid: string, options?: any): AxiosPromise<ConnectorCluster> {
            return localVarFp.getConnectorCluster(id, cid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a connector cluster\'s addon parameters
         * @param {string} id The id of record
         * @param {string} cid The id of the connector cluster
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorClusterAddonParameters(id: string, cid: string, options?: any): AxiosPromise<Array<AddonParameter>> {
            return localVarFp.getConnectorClusterAddonParameters(id, cid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a connector type by name and version
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorTypeByID(id: string, options?: any): AxiosPromise<ConnectorType> {
            return localVarFp.getConnectorTypeByID(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the spec of the ManagedKafkaAgent CR spec
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKafkaAgent(id: string, options?: any): AxiosPromise<DataplaneClusterAgentConfig> {
            return localVarFp.getKafkaAgent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a kafka request by id
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKafkaById(id: string, options?: any): AxiosPromise<KafkaRequest> {
            return localVarFp.getKafkaById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of ManagedaKafkas for the specified agent cluster
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKafkas(id: string, options?: any): AxiosPromise<ManagedKafkaList> {
            return localVarFp.getKafkas(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get metrics with instant query by kafka id.
         * @param {string} id The id of record
         * @param {Array<string>} [filters] List of metrics to fetch. Fetch all metrics when empty. List entries are kafka internal metric names.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsByInstantQuery(id: string, filters?: Array<string>, options?: any): AxiosPromise<MetricsInstantQueryList> {
            return localVarFp.getMetricsByInstantQuery(id, filters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get metrics with timeseries range query by kafka id.
         * @param {string} id The id of record
         * @param {number} duration The length of time in minutes over which to return the metrics.
         * @param {number} interval The interval in seconds between data points.
         * @param {Array<string>} [filters] List of metrics to fetch. Fetch all metrics when empty. List entries are kafka internal metric names.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsByRangeQuery(id: string, duration: number, interval: number, filters?: Array<string>, options?: any): AxiosPromise<MetricsRangeQueryList> {
            return localVarFp.getMetricsByRangeQuery(id, duration, interval, filters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get service account by id
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAccountById(id: string, options?: any): AxiosPromise<ServiceAccount> {
            return localVarFp.getServiceAccountById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the list of supported regions of the supported cloud provider.
         * @param {string} id The id of record
         * @param {string} [page] Page index
         * @param {string} [size] Number of items in each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCloudProviderRegions(id: string, page?: string, size?: string, options?: any): AxiosPromise<CloudRegionList> {
            return localVarFp.listCloudProviderRegions(id, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the list of supported cloud providers.
         * @param {string} [page] Page index
         * @param {string} [size] Number of items in each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCloudProviders(page?: string, size?: string, options?: any): AxiosPromise<CloudProviderList> {
            return localVarFp.listCloudProviders(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of connector types
         * @param {string} id The id of record
         * @param {string} [page] Page index
         * @param {string} [size] Number of items in each page
         * @param {number} [gtVersion] filters the connectors to those with a version greater than the given value
         * @param {boolean} [watch] watch for changes to the resources and return them as a stream of watch events. Specify gt_version to specify the starting point.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusterAsignedConnectors(id: string, page?: string, size?: string, gtVersion?: number, watch?: boolean, options?: any): AxiosPromise<ConnectorList> {
            return localVarFp.listClusterAsignedConnectors(id, page, size, gtVersion, watch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of connector clusters
         * @param {string} id The id of record
         * @param {string} [page] Page index
         * @param {string} [size] Number of items in each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectorClusters(id: string, page?: string, size?: string, options?: any): AxiosPromise<ConnectorClusterList> {
            return localVarFp.listConnectorClusters(id, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of connector types
         * @param {string} [page] Page index
         * @param {string} [size] Number of items in each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectorTypes(page?: string, size?: string, options?: any): AxiosPromise<ConnectorTypeList> {
            return localVarFp.listConnectorTypes(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of connector types
         * @param {string} id The id of record
         * @param {string} [page] Page index
         * @param {string} [size] Number of items in each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectors(id: string, page?: string, size?: string, options?: any): AxiosPromise<ConnectorList> {
            return localVarFp.listConnectors(id, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of Kafka requests
         * @param {string} [page] Page index
         * @param {string} [size] Number of items in each page
         * @param {string} [orderBy] Specifies the order by criteria. The syntax of this parameter is similar to the syntax of the _order by_ clause of an SQL statement. Each query can be ordered by any of the kafkaRequests fields. For example, in order to retrieve all kafkas ordered by their name:  &#x60;&#x60;&#x60;sql name asc &#x60;&#x60;&#x60;  Or in order to retrieve all kafkas ordered by their name _and_ created date:  &#x60;&#x60;&#x60;sql name asc, created_at asc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the results will be ordered by name.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement. Allowed fields in the search are: cloud_provider, name, owner, region and status. Allowed comparators are &#x60;&lt;&gt;&#x60;, &#x60;&#x3D;&#x60; or &#x60;LIKE&#x60;. Allowed joins are &#x60;AND&#x60; and &#x60;OR&#x60;, however there is a limit of max 10 joins in the search query.  Examples:  To retrieve kafka request with name equal &#x60;my-kafka&#x60; and region equal &#x60;aws&#x60;, the value should be:  &#x60;&#x60;&#x60; name &#x3D; my-kafka and cloud_provider &#x3D; aws &#x60;&#x60;&#x60;  To retrieve kafka request with its name starting with &#x60;my&#x60;, the value should be:  &#x60;&#x60;&#x60; name like my%25 &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the kafkas that the user has permission to see will be returned.  Note. If the query is invalid, an error will be returned 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKafkas(page?: string, size?: string, orderBy?: string, search?: string, options?: any): AxiosPromise<KafkaRequestList> {
            return localVarFp.listKafkas(page, size, orderBy, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List service accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceAccounts(options?: any): AxiosPromise<ServiceAccountList> {
            return localVarFp.listServiceAccounts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary reset credentials for the service account
         * @param {string} id The id of record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetServiceAccountCreds(id: string, options?: any): AxiosPromise<ServiceAccount> {
            return localVarFp.resetServiceAccountCreds(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the status of resources e.g whether we have reached maximum service capacity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceStatus(options?: any): AxiosPromise<ServiceStatus> {
            return localVarFp.serviceStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the status of an agent cluster
         * @param {string} id The id of record
         * @param {DataPlaneClusterUpdateStatusRequest} dataPlaneClusterUpdateStatusRequest Cluster status update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAgentClusterStatus(id: string, dataPlaneClusterUpdateStatusRequest: DataPlaneClusterUpdateStatusRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateAgentClusterStatus(id, dataPlaneClusterUpdateStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the status of Kafka clusters on an agent cluster
         * @param {string} id The id of record
         * @param {{ [key: string]: DataPlaneKafkaStatus; }} requestBody Kafka clusters status update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKafkaClusterStatus(id: string, requestBody: { [key: string]: DataPlaneKafkaStatus; }, options?: any): AxiosPromise<void> {
            return localVarFp.updateKafkaClusterStatus(id, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the status of a connector agent cluster
         * @param {string} id The id of record
         * @param {ConnectorClusterUpdateStatus} connectorClusterUpdateStatus Cluster status update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKafkaConnectorAgentClusterStatus(id: string, connectorClusterUpdateStatus: ConnectorClusterUpdateStatus, options?: any): AxiosPromise<void> {
            return localVarFp.updateKafkaConnectorAgentClusterStatus(id, connectorClusterUpdateStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the status of a connector agent cluster
         * @param {string} id The id of record
         * @param {string} cid The id of the connector
         * @param {ConnectorUpdateStatus} connectorUpdateStatus Cluster status update data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKafkaConnectorStatus(id: string, cid: string, connectorUpdateStatus: ConnectorUpdateStatus, options?: any): AxiosPromise<void> {
            return localVarFp.updateKafkaConnectorStatus(id, cid, connectorUpdateStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the version metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionMetadata(options?: any): AxiosPromise<VersionMetadata> {
            return localVarFp.versionMetadata(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
    /**
     * Deletes the add-on. 
     * @param {string} addonId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AddonsAddonIdDelete(addonId: string, options?: any): AxiosPromise<void>;

    /**
     * Retrieves the details of the add-on. 
     * @param {string} addonId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AddonsAddonIdGet(addonId: string, options?: any): AxiosPromise<AddOn>;

    /**
     * Updates the add-on. 
     * @param {string} addonId 
     * @param {AddOn} [addOn] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AddonsAddonIdPatch(addonId: string, addOn?: AddOn, options?: any): AxiosPromise<AddOn>;

    /**
     * Retrieves the list of add-ons. 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-ons descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to retrieve all the add-ons with a name starting with &#x60;my&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-ons that the user has permission to see will be returned. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AddonsGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse200>;

    /**
     * Create a new add-on and add it to the collection of add-ons. 
     * @param {AddOn} [addOn] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AddonsPost(addOn?: AddOn, options?: any): AxiosPromise<AddOn>;

    /**
     * Retrieves the details of the aws infrastructure access role. 
     * @param {string} awsInfrastructureAccessRoleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet(awsInfrastructureAccessRoleId: string, options?: any): AxiosPromise<AWSInfrastructureAccessRole>;

    /**
     * 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to sort the roles descending by dislay_name the value should be:   &#x60;&#x60;&#x60; display_name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to retrieve all the role with a name starting with &#x60;my&#x60;the value should be:   &#x60;&#x60;&#x60; display_name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the roles that the user has permission to see will be returned. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1AwsInfrastructureAccessRolesGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse2001>;

    /**
     * Retrieves the list of available regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider. 
     * @param {string} cloudProviderId 
     * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;. 
     * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider. 
     * @param {AWS} [aWS] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost(cloudProviderId: string, page?: number, size?: number, aWS?: AWS, options?: any): AxiosPromise<InlineResponse2003>;

    /**
     * Retrieves the details of the cloud provider. 
     * @param {string} cloudProviderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1CloudProvidersCloudProviderIdGet(cloudProviderId: string, options?: any): AxiosPromise<CloudProvider1>;

    /**
     * Retrieves the list of regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of regions of the provider. 
     * @param {string} cloudProviderId 
     * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;. 
     * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet(cloudProviderId: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse2004>;

    /**
     * Retrieves the details of the region. 
     * @param {string} cloudProviderId 
     * @param {string} regionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet(cloudProviderId: string, regionId: string, options?: any): AxiosPromise<CloudRegion1>;

    /**
     * Retrieves the list of cloud providers. 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to sort the clusters descending by name identifier the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to retrieve all the cloud providers with a name starting with &#x60;A&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1CloudProvidersGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse2002>;

    /**
     * Delete an add-on installation and remove it from the collection of add-on installations on the cluster. 
     * @param {string} clusterId 
     * @param {string} addoninstallationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete(clusterId: string, addoninstallationId: string, options?: any): AxiosPromise<void>;

    /**
     * Retrieves the details of the add-on installation. 
     * @param {string} clusterId 
     * @param {string} addoninstallationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet(clusterId: string, addoninstallationId: string, options?: any): AxiosPromise<AddOnInstallation>;

    /**
     * Updates the add-on installation. 
     * @param {string} clusterId 
     * @param {string} addoninstallationId 
     * @param {AddOnInstallation} [addOnInstallation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch(clusterId: string, addoninstallationId: string, addOnInstallation?: AddOnInstallation, options?: any): AxiosPromise<AddOnInstallation>;

    /**
     * Retrieves the list of add-on installations. 
     * @param {string} clusterId 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to sort the add-on installations descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to retrieve all the add-on installations with a name starting with &#x60;my&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-on installations that the user has permission to see will be returned. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdAddonsGet(clusterId: string, order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse2006>;

    /**
     * Create a new add-on installation and add it to the collection of add-on installations on the cluster. 
     * @param {string} clusterId 
     * @param {AddOnInstallation} [addOnInstallation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdAddonsPost(clusterId: string, addOnInstallation?: AddOnInstallation, options?: any): AxiosPromise<AddOnInstallation>;

    /**
     * Deletes the AWS infrastructure access role grant. 
     * @param {string} clusterId 
     * @param {string} awsInfrastructureAccessRoleGrantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete(clusterId: string, awsInfrastructureAccessRoleGrantId: string, options?: any): AxiosPromise<void>;

    /**
     * Retrieves the details of the AWS infrastructure access role grant. 
     * @param {string} clusterId 
     * @param {string} awsInfrastructureAccessRoleGrantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet(clusterId: string, awsInfrastructureAccessRoleGrantId: string, options?: any): AxiosPromise<AWSInfrastructureAccessRoleGrant>;

    /**
     * Retrieves the list of AWS infrastructure access role grants. 
     * @param {string} clusterId 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to sort the AWS infrastructure access role grants descending by user ARN the value should be:   &#x60;&#x60;&#x60; user_arn desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to retrieve all the AWS infrastructure access role grants with a user ARN starting with &#x60;user&#x60; the value should be:   &#x60;&#x60;&#x60; user_arn like \&#39;%user\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the AWS infrastructure access role grants that the user has permission to see will be returned. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet(clusterId: string, order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse2007>;

    /**
     * Create a new AWS infrastructure access role grant and add it to the collection of AWS infrastructure access role grants on the cluster. 
     * @param {string} clusterId 
     * @param {AWSInfrastructureAccessRoleGrant} [aWSInfrastructureAccessRoleGrant] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost(clusterId: string, aWSInfrastructureAccessRoleGrant?: AWSInfrastructureAccessRoleGrant, options?: any): AxiosPromise<AWSInfrastructureAccessRoleGrant>;

    /**
     * Retrieves the details of the credentials of a cluster. 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdCredentialsGet(clusterId: string, options?: any): AxiosPromise<ClusterCredentials>;

    /**
     * Deletes the cluster. 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdDelete(clusterId: string, options?: any): AxiosPromise<void>;

    /**
     * Retrieves the details of the external configuration. 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet(clusterId: string, options?: any): AxiosPromise<ExternalConfiguration>;

    /**
     * Retrieves the list of labels. 
     * @param {string} clusterId 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {number} [size] Number of items contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet(clusterId: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse2008>;

    /**
     * Deletes the label. 
     * @param {string} clusterId 
     * @param {string} labelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete(clusterId: string, labelId: string, options?: any): AxiosPromise<void>;

    /**
     * Retrieves the details of the label. 
     * @param {string} clusterId 
     * @param {string} labelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet(clusterId: string, labelId: string, options?: any): AxiosPromise<Label>;

    /**
     * Update the label. 
     * @param {string} clusterId 
     * @param {string} labelId 
     * @param {Label} [label] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch(clusterId: string, labelId: string, label?: Label, options?: any): AxiosPromise<Label>;

    /**
     * Adds a new label to the cluster. 
     * @param {string} clusterId 
     * @param {Label} [label] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost(clusterId: string, label?: Label, options?: any): AxiosPromise<Label>;

    /**
     * Retrieves the list of syncsets. 
     * @param {string} clusterId 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {number} [size] Number of items contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet(clusterId: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse2009>;

    /**
     * Adds a new syncset to the cluster. 
     * @param {string} clusterId 
     * @param {Syncset} [syncset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost(clusterId: string, syncset?: Syncset, options?: any): AxiosPromise<Syncset>;

    /**
     * Deletes the syncset. 
     * @param {string} clusterId 
     * @param {string} syncsetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete(clusterId: string, syncsetId: string, options?: any): AxiosPromise<void>;

    /**
     * Retrieves the details of the syncset. 
     * @param {string} clusterId 
     * @param {string} syncsetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet(clusterId: string, syncsetId: string, options?: any): AxiosPromise<Syncset>;

    /**
     * Update the syncset. 
     * @param {string} clusterId 
     * @param {string} syncsetId 
     * @param {Syncset} [syncset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch(clusterId: string, syncsetId: string, syncset?: Syncset, options?: any): AxiosPromise<Syncset>;

    /**
     * Retrieves the details of the cluster. 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdGet(clusterId: string, options?: any): AxiosPromise<Cluster>;

    /**
     * Retrieves the list of groups. 
     * @param {string} clusterId 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {number} [size] Number of items contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdGroupsGet(clusterId: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20010>;

    /**
     * Retrieves the details of the group. 
     * @param {string} clusterId 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet(clusterId: string, groupId: string, options?: any): AxiosPromise<Group>;

    /**
     * Retrieves the list of users. 
     * @param {string} clusterId 
     * @param {string} groupId 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {number} [size] Number of items contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet(clusterId: string, groupId: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20011>;

    /**
     * Adds a new user to the group. 
     * @param {string} clusterId 
     * @param {string} groupId 
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost(clusterId: string, groupId: string, user?: User, options?: any): AxiosPromise<User>;

    /**
     * Deletes the user. 
     * @param {string} clusterId 
     * @param {string} groupId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete(clusterId: string, groupId: string, userId: string, options?: any): AxiosPromise<void>;

    /**
     * Retrieves the details of the user. 
     * @param {string} clusterId 
     * @param {string} groupId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet(clusterId: string, groupId: string, userId: string, options?: any): AxiosPromise<User>;

    /**
     * Initiates cluster hibernation. While hibernating a cluster will not consume any cloud provider infrastructure but will be counted for quota. 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdHibernatePost(clusterId: string, options?: any): AxiosPromise<void>;

    /**
     * Retrieves the list of identity providers. 
     * @param {string} clusterId 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {number} [size] Number of items contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet(clusterId: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20012>;

    /**
     * Deletes the identity provider. 
     * @param {string} clusterId 
     * @param {string} identityProviderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete(clusterId: string, identityProviderId: string, options?: any): AxiosPromise<void>;

    /**
     * Retrieves the details of the identity provider. 
     * @param {string} clusterId 
     * @param {string} identityProviderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet(clusterId: string, identityProviderId: string, options?: any): AxiosPromise<IdentityProvider>;

    /**
     * Update identity provider in the cluster. 
     * @param {string} clusterId 
     * @param {string} identityProviderId 
     * @param {IdentityProvider} [identityProvider] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch(clusterId: string, identityProviderId: string, identityProvider?: IdentityProvider, options?: any): AxiosPromise<IdentityProvider>;

    /**
     * Adds a new identity provider to the cluster. 
     * @param {string} clusterId 
     * @param {IdentityProvider} [identityProvider] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost(clusterId: string, identityProvider?: IdentityProvider, options?: any): AxiosPromise<IdentityProvider>;

    /**
     * Retrieves the list of ingresses. 
     * @param {string} clusterId 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {number} [size] Number of items contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIngressesGet(clusterId: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20013>;

    /**
     * Deletes the ingress. 
     * @param {string} clusterId 
     * @param {string} ingressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete(clusterId: string, ingressId: string, options?: any): AxiosPromise<void>;

    /**
     * Retrieves the details of the ingress. 
     * @param {string} clusterId 
     * @param {string} ingressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet(clusterId: string, ingressId: string, options?: any): AxiosPromise<Ingress>;

    /**
     * Updates the ingress. 
     * @param {string} clusterId 
     * @param {string} ingressId 
     * @param {Ingress} [ingress] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch(clusterId: string, ingressId: string, ingress?: Ingress, options?: any): AxiosPromise<Ingress>;

    /**
     * Updates all ingresses 
     * @param {string} clusterId 
     * @param {Array<Ingress>} [ingress] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIngressesPatch(clusterId: string, ingress?: Array<Ingress>, options?: any): AxiosPromise<Array<Ingress>>;

    /**
     * Adds a new ingress to the cluster. 
     * @param {string} clusterId 
     * @param {Ingress} [ingress] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdIngressesPost(clusterId: string, ingress?: Ingress, options?: any): AxiosPromise<Ingress>;

    /**
     * Retrieves the list of log links. 
     * @param {string} clusterId 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {number} [size] Number of items contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdLogsGet(clusterId: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20014>;

    /**
     * Retrieves the details of the log. 
     * @param {string} clusterId 
     * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log. 
     * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdLogsInstallGet(clusterId: string, offset?: number, tail?: number, options?: any): AxiosPromise<Log>;

    /**
     * Retrieves the details of the log. 
     * @param {string} clusterId 
     * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log. 
     * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdLogsUninstallGet(clusterId: string, offset?: number, tail?: number, options?: any): AxiosPromise<Log>;

    /**
     * Retrieves the list of machine pools. 
     * @param {string} clusterId 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {number} [size] Number of items contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdMachinePoolsGet(clusterId: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20015>;

    /**
     * Deletes the machine pool. 
     * @param {string} clusterId 
     * @param {string} machinePoolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete(clusterId: string, machinePoolId: string, options?: any): AxiosPromise<void>;

    /**
     * Retrieves the details of the machine pool. 
     * @param {string} clusterId 
     * @param {string} machinePoolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet(clusterId: string, machinePoolId: string, options?: any): AxiosPromise<MachinePool>;

    /**
     * Updates the machine pool. 
     * @param {string} clusterId 
     * @param {string} machinePoolId 
     * @param {MachinePool} [machinePool] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch(clusterId: string, machinePoolId: string, machinePool?: MachinePool, options?: any): AxiosPromise<MachinePool>;

    /**
     * Adds a new machine pool to the cluster. 
     * @param {string} clusterId 
     * @param {MachinePool} [machinePool] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdMachinePoolsPost(clusterId: string, machinePool?: MachinePool, options?: any): AxiosPromise<MachinePool>;

    /**
     * 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet(clusterId: string, options?: any): AxiosPromise<AlertsInfo>;

    /**
     * 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet(clusterId: string, options?: any): AxiosPromise<ClusterOperatorsInfo>;

    /**
     * Retrieves the metrics. 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet(clusterId: string, options?: any): AxiosPromise<CPUTotalsNodeRoleOSMetricNode>;

    /**
     * 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet(clusterId: string, options?: any): AxiosPromise<NodesInfo>;

    /**
     * Retrieves the metrics. 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet(clusterId: string, options?: any): AxiosPromise<SocketTotalsNodeRoleOSMetricNode>;

    /**
     * Updates the cluster. 
     * @param {string} clusterId 
     * @param {Cluster} [cluster] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdPatch(clusterId: string, cluster?: Cluster, options?: any): AxiosPromise<Cluster>;

    /**
     * Retrieves the details of the product. 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdProductGet(clusterId: string, options?: any): AxiosPromise<Product>;

    /**
     * Retrieves the details of the provision shard. 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdProvisionShardGet(clusterId: string, options?: any): AxiosPromise<ProvisionShard>;

    /**
     * Resumes from Hibernation. 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdResumePost(clusterId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdStatusGet(clusterId: string, options?: any): AxiosPromise<ClusterStatus>;

    /**
     * Retrieves the list of upgrade policies. 
     * @param {string} clusterId 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {number} [size] Number of items contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet(clusterId: string, page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20016>;

    /**
     * Adds a new upgrade policy to the cluster. 
     * @param {string} clusterId 
     * @param {UpgradePolicy} [upgradePolicy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost(clusterId: string, upgradePolicy?: UpgradePolicy, options?: any): AxiosPromise<UpgradePolicy>;

    /**
     * Deletes the upgrade policy. 
     * @param {string} clusterId 
     * @param {string} upgradePolicyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete(clusterId: string, upgradePolicyId: string, options?: any): AxiosPromise<void>;

    /**
     * Retrieves the details of the upgrade policy. 
     * @param {string} clusterId 
     * @param {string} upgradePolicyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet(clusterId: string, upgradePolicyId: string, options?: any): AxiosPromise<UpgradePolicy>;

    /**
     * Update the upgrade policy. 
     * @param {string} clusterId 
     * @param {string} upgradePolicyId 
     * @param {UpgradePolicy} [upgradePolicy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch(clusterId: string, upgradePolicyId: string, upgradePolicy?: UpgradePolicy, options?: any): AxiosPromise<UpgradePolicy>;

    /**
     * Retrieves the details of the upgrade policy state. 
     * @param {string} clusterId 
     * @param {string} upgradePolicyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet(clusterId: string, upgradePolicyId: string, options?: any): AxiosPromise<UpgradePolicyState>;

    /**
     * Update the upgrade policy state. 
     * @param {string} clusterId 
     * @param {string} upgradePolicyId 
     * @param {UpgradePolicyState} [upgradePolicyState] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch(clusterId: string, upgradePolicyId: string, upgradePolicyState?: UpgradePolicyState, options?: any): AxiosPromise<UpgradePolicyState>;

    /**
     * Retrieves the list of clusters. 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to sort the clusters descending by region identifier the value should be:   &#x60;&#x60;&#x60; region.id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to retrieve all the clusters with a name starting with &#x60;my&#x60; in the &#x60;us-east-1&#x60; region the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; and region.id &#x3D; \&#39;us-east-1\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse2005>;

    /**
     * Provision a new cluster and add it to the collection of clusters.  See the `register_cluster` method for adding an existing cluster. 
     * @param {Cluster} [cluster] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ClustersPost(cluster?: Cluster, options?: any): AxiosPromise<Cluster>;

    /**
     * Retrieves the details of the dashboard. 
     * @param {string} dashboardId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1DashboardsDashboardIdGet(dashboardId: string, options?: any): AxiosPromise<Dashboard>;

    /**
     * Retrieves a list of dashboards. 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the dashboard instead of the names of the columns of a table. For example, in order to sort the dashboards descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the dashboard instead of the names of the columns of a table. For example, in order to retrieve all the dashboards with a name starting with &#x60;my&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the dashboards that the user has permission to see will be returned. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1DashboardsGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse20017>;

    /**
     * Retrieves the details of the cluster flavour. 
     * @param {string} flavourId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1FlavoursFlavourIdGet(flavourId: string, options?: any): AxiosPromise<Flavour>;

    /**
     * Updates the flavour.  Attributes that can be updated are:  - `aws.infra_volume` - `aws.infra_instance_type` - `gcp.infra_instance_type` 
     * @param {string} flavourId 
     * @param {Flavour} [flavour] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1FlavoursFlavourIdPatch(flavourId: string, flavour?: Flavour, options?: any): AxiosPromise<Flavour>;

    /**
     * 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to sort the flavours descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to retrieve all the flavours with a name starting with &#x60;my&#x60;the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the flavours that the user has permission to see will be returned. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1FlavoursGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse20018>;

    /**
     * Adds a new cluster flavour. 
     * @param {Flavour} [flavour] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1FlavoursPost(flavour?: Flavour, options?: any): AxiosPromise<Flavour>;

    /**
     * Retrieves the version metadata. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1Get(options?: any): AxiosPromise<Metadata>;

    /**
     * Retrieves the list of machine types. 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to sort the machine types descending by name identifier the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to retrieve all the machine types with a name starting with &#x60;A&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the machine types that the user has permission to see will be returned. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1MachineTypesGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse20019>;

    /**
     * Retrieves the list of products. 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to sort the products descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to retrieve all the products with a name starting with &#x60;my&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the products that the user has permission to see will be returned. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ProductsGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse20020>;

    /**
     * Retrieves the details of the product. 
     * @param {string} productId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ProductsProductIdGet(productId: string, options?: any): AxiosPromise<Product>;

    /**
     * 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ProvisionShardsGet(page?: number, size?: number, options?: any): AxiosPromise<InlineResponse20021>;

    /**
     * Retrieves the details of the provision shard. 
     * @param {string} provisionShardId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1ProvisionShardsProvisionShardIdGet(provisionShardId: string, options?: any): AxiosPromise<ProvisionShard>;

    /**
     * Retrieves a list of versions. 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to sort the versions descending by identifier the value should be:   &#x60;&#x60;&#x60; id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to retrieve all the versions that are enabled:   &#x60;&#x60;&#x60; enabled &#x3D; \&#39;t\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the versions that the user has permission to see will be returned. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page.  Default value is &#x60;100&#x60;. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1VersionsGet(order?: string, page?: number, search?: string, size?: number, options?: any): AxiosPromise<InlineResponse20022>;

    /**
     * Retrieves the details of the version. 
     * @param {string} versionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    apiClustersMgmtV1VersionsVersionIdGet(versionId: string, options?: any): AxiosPromise<Version>;

    /**
     * 
     * @summary Create a new connector
     * @param {string} id The id of record
     * @param {boolean} async Perform the action in an asynchronous manner
     * @param {Connector} connector Connector data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    createConnector(id: string, async: boolean, connector: Connector, options?: any): AxiosPromise<Connector>;

    /**
     * 
     * @summary Create a new connector cluster
     * @param {string} id The id of record
     * @param {boolean} async Perform the action in an asynchronous manner
     * @param {ConnectorCluster} connectorCluster Connector cluster data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    createConnectorCluster(id: string, async: boolean, connectorCluster: ConnectorCluster, options?: any): AxiosPromise<ConnectorCluster>;

    /**
     * 
     * @summary Create a new kafka Request
     * @param {boolean} async Perform the action in an asynchronous manner
     * @param {KafkaRequestPayload} kafkaRequestPayload Kafka data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    createKafka(async: boolean, kafkaRequestPayload: KafkaRequestPayload, options?: any): AxiosPromise<KafkaRequest>;

    /**
     * 
     * @summary Create a service account
     * @param {ServiceAccountRequest} serviceAccountRequest service account request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    createServiceAccount(serviceAccountRequest: ServiceAccountRequest, options?: any): AxiosPromise<ServiceAccount>;

    /**
     * 
     * @summary Delete a connector
     * @param {string} id The id of record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteConnector(id: string, options?: any): AxiosPromise<Error>;

    /**
     * 
     * @summary Delete a connector cluster
     * @param {string} id The id of record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteConnectorCluster(id: string, options?: any): AxiosPromise<Error>;

    /**
     * 
     * @summary Delete a kafka request by id
     * @param {string} id The id of record
     * @param {boolean} async Perform the action in an asynchronous manner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteKafkaById(id: string, async: boolean, options?: any): AxiosPromise<Error>;

    /**
     * 
     * @summary Delete service account
     * @param {string} id The id of record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteServiceAccount(id: string, options?: any): AxiosPromise<Error>;

    /**
     * 
     * @summary Get a connector deployment
     * @param {string} id The id of record
     * @param {string} cid The id of the connector
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getConnector(id: string, cid: string, options?: any): AxiosPromise<Connector>;

    /**
     * 
     * @summary Get a connector cluster
     * @param {string} id The id of record
     * @param {string} cid The id of the connector cluster
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getConnectorCluster(id: string, cid: string, options?: any): AxiosPromise<ConnectorCluster>;

    /**
     * 
     * @summary Get a connector cluster\'s addon parameters
     * @param {string} id The id of record
     * @param {string} cid The id of the connector cluster
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getConnectorClusterAddonParameters(id: string, cid: string, options?: any): AxiosPromise<Array<AddonParameter>>;

    /**
     * 
     * @summary Get a connector type by name and version
     * @param {string} id The id of record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getConnectorTypeByID(id: string, options?: any): AxiosPromise<ConnectorType>;

    /**
     * 
     * @summary Get the spec of the ManagedKafkaAgent CR spec
     * @param {string} id The id of record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getKafkaAgent(id: string, options?: any): AxiosPromise<DataplaneClusterAgentConfig>;

    /**
     * 
     * @summary Get a kafka request by id
     * @param {string} id The id of record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getKafkaById(id: string, options?: any): AxiosPromise<KafkaRequest>;

    /**
     * 
     * @summary Get the list of ManagedaKafkas for the specified agent cluster
     * @param {string} id The id of record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getKafkas(id: string, options?: any): AxiosPromise<ManagedKafkaList>;

    /**
     * 
     * @summary Get metrics with instant query by kafka id.
     * @param {string} id The id of record
     * @param {Array<string>} [filters] List of metrics to fetch. Fetch all metrics when empty. List entries are kafka internal metric names.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getMetricsByInstantQuery(id: string, filters?: Array<string>, options?: any): AxiosPromise<MetricsInstantQueryList>;

    /**
     * 
     * @summary Get metrics with timeseries range query by kafka id.
     * @param {string} id The id of record
     * @param {number} duration The length of time in minutes over which to return the metrics.
     * @param {number} interval The interval in seconds between data points.
     * @param {Array<string>} [filters] List of metrics to fetch. Fetch all metrics when empty. List entries are kafka internal metric names.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getMetricsByRangeQuery(id: string, duration: number, interval: number, filters?: Array<string>, options?: any): AxiosPromise<MetricsRangeQueryList>;

    /**
     * 
     * @summary get service account by id
     * @param {string} id The id of record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getServiceAccountById(id: string, options?: any): AxiosPromise<ServiceAccount>;

    /**
     * 
     * @summary Retrieves the list of supported regions of the supported cloud provider.
     * @param {string} id The id of record
     * @param {string} [page] Page index
     * @param {string} [size] Number of items in each page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    listCloudProviderRegions(id: string, page?: string, size?: string, options?: any): AxiosPromise<CloudRegionList>;

    /**
     * 
     * @summary Retrieves the list of supported cloud providers.
     * @param {string} [page] Page index
     * @param {string} [size] Number of items in each page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    listCloudProviders(page?: string, size?: string, options?: any): AxiosPromise<CloudProviderList>;

    /**
     * 
     * @summary Returns a list of connector types
     * @param {string} id The id of record
     * @param {string} [page] Page index
     * @param {string} [size] Number of items in each page
     * @param {number} [gtVersion] filters the connectors to those with a version greater than the given value
     * @param {boolean} [watch] watch for changes to the resources and return them as a stream of watch events. Specify gt_version to specify the starting point.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    listClusterAsignedConnectors(id: string, page?: string, size?: string, gtVersion?: number, watch?: boolean, options?: any): AxiosPromise<ConnectorList>;

    /**
     * 
     * @summary Returns a list of connector clusters
     * @param {string} id The id of record
     * @param {string} [page] Page index
     * @param {string} [size] Number of items in each page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    listConnectorClusters(id: string, page?: string, size?: string, options?: any): AxiosPromise<ConnectorClusterList>;

    /**
     * 
     * @summary Returns a list of connector types
     * @param {string} [page] Page index
     * @param {string} [size] Number of items in each page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    listConnectorTypes(page?: string, size?: string, options?: any): AxiosPromise<ConnectorTypeList>;

    /**
     * 
     * @summary Returns a list of connector types
     * @param {string} id The id of record
     * @param {string} [page] Page index
     * @param {string} [size] Number of items in each page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    listConnectors(id: string, page?: string, size?: string, options?: any): AxiosPromise<ConnectorList>;

    /**
     * 
     * @summary Returns a list of Kafka requests
     * @param {string} [page] Page index
     * @param {string} [size] Number of items in each page
     * @param {string} [orderBy] Specifies the order by criteria. The syntax of this parameter is similar to the syntax of the _order by_ clause of an SQL statement. Each query can be ordered by any of the kafkaRequests fields. For example, in order to retrieve all kafkas ordered by their name:  &#x60;&#x60;&#x60;sql name asc &#x60;&#x60;&#x60;  Or in order to retrieve all kafkas ordered by their name _and_ created date:  &#x60;&#x60;&#x60;sql name asc, created_at asc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the results will be ordered by name.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement. Allowed fields in the search are: cloud_provider, name, owner, region and status. Allowed comparators are &#x60;&lt;&gt;&#x60;, &#x60;&#x3D;&#x60; or &#x60;LIKE&#x60;. Allowed joins are &#x60;AND&#x60; and &#x60;OR&#x60;, however there is a limit of max 10 joins in the search query.  Examples:  To retrieve kafka request with name equal &#x60;my-kafka&#x60; and region equal &#x60;aws&#x60;, the value should be:  &#x60;&#x60;&#x60; name &#x3D; my-kafka and cloud_provider &#x3D; aws &#x60;&#x60;&#x60;  To retrieve kafka request with its name starting with &#x60;my&#x60;, the value should be:  &#x60;&#x60;&#x60; name like my%25 &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the kafkas that the user has permission to see will be returned.  Note. If the query is invalid, an error will be returned 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    listKafkas(page?: string, size?: string, orderBy?: string, search?: string, options?: any): AxiosPromise<KafkaRequestList>;

    /**
     * 
     * @summary List service accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    listServiceAccounts(options?: any): AxiosPromise<ServiceAccountList>;

    /**
     * 
     * @summary reset credentials for the service account
     * @param {string} id The id of record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    resetServiceAccountCreds(id: string, options?: any): AxiosPromise<ServiceAccount>;

    /**
     * 
     * @summary Retrieves the status of resources e.g whether we have reached maximum service capacity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    serviceStatus(options?: any): AxiosPromise<ServiceStatus>;

    /**
     * 
     * @summary Update the status of an agent cluster
     * @param {string} id The id of record
     * @param {DataPlaneClusterUpdateStatusRequest} dataPlaneClusterUpdateStatusRequest Cluster status update data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    updateAgentClusterStatus(id: string, dataPlaneClusterUpdateStatusRequest: DataPlaneClusterUpdateStatusRequest, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Update the status of Kafka clusters on an agent cluster
     * @param {string} id The id of record
     * @param {{ [key: string]: DataPlaneKafkaStatus; }} requestBody Kafka clusters status update data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    updateKafkaClusterStatus(id: string, requestBody: { [key: string]: DataPlaneKafkaStatus; }, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Update the status of a connector agent cluster
     * @param {string} id The id of record
     * @param {ConnectorClusterUpdateStatus} connectorClusterUpdateStatus Cluster status update data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    updateKafkaConnectorAgentClusterStatus(id: string, connectorClusterUpdateStatus: ConnectorClusterUpdateStatus, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Update the status of a connector agent cluster
     * @param {string} id The id of record
     * @param {string} cid The id of the connector
     * @param {ConnectorUpdateStatus} connectorUpdateStatus Cluster status update data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    updateKafkaConnectorStatus(id: string, cid: string, connectorUpdateStatus: ConnectorUpdateStatus, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Retrieves the version metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    versionMetadata(options?: any): AxiosPromise<VersionMetadata>;

}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * Deletes the add-on. 
     * @param {string} addonId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsAddonIdDelete(addonId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsAddonIdDelete(addonId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the add-on. 
     * @param {string} addonId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsAddonIdGet(addonId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsAddonIdGet(addonId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the add-on. 
     * @param {string} addonId 
     * @param {AddOn} [addOn] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsAddonIdPatch(addonId: string, addOn?: AddOn, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsAddonIdPatch(addonId, addOn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of add-ons. 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-ons descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to retrieve all the add-ons with a name starting with &#x60;my&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-ons that the user has permission to see will be returned. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsGet(order?: string, page?: number, search?: string, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsGet(order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new add-on and add it to the collection of add-ons. 
     * @param {AddOn} [addOn] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsPost(addOn?: AddOn, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsPost(addOn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the aws infrastructure access role. 
     * @param {string} awsInfrastructureAccessRoleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet(awsInfrastructureAccessRoleId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet(awsInfrastructureAccessRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to sort the roles descending by dislay_name the value should be:   &#x60;&#x60;&#x60; display_name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to retrieve all the role with a name starting with &#x60;my&#x60;the value should be:   &#x60;&#x60;&#x60; display_name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the roles that the user has permission to see will be returned. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AwsInfrastructureAccessRolesGet(order?: string, page?: number, search?: string, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AwsInfrastructureAccessRolesGet(order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of available regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider. 
     * @param {string} cloudProviderId 
     * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;. 
     * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider. 
     * @param {AWS} [aWS] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost(cloudProviderId: string, page?: number, size?: number, aWS?: AWS, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost(cloudProviderId, page, size, aWS, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the cloud provider. 
     * @param {string} cloudProviderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1CloudProvidersCloudProviderIdGet(cloudProviderId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1CloudProvidersCloudProviderIdGet(cloudProviderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of regions of the provider. 
     * @param {string} cloudProviderId 
     * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;. 
     * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet(cloudProviderId: string, page?: number, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet(cloudProviderId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the region. 
     * @param {string} cloudProviderId 
     * @param {string} regionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet(cloudProviderId: string, regionId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet(cloudProviderId, regionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of cloud providers. 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to sort the clusters descending by name identifier the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to retrieve all the cloud providers with a name starting with &#x60;A&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1CloudProvidersGet(order?: string, page?: number, search?: string, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1CloudProvidersGet(order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an add-on installation and remove it from the collection of add-on installations on the cluster. 
     * @param {string} clusterId 
     * @param {string} addoninstallationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete(clusterId: string, addoninstallationId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete(clusterId, addoninstallationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the add-on installation. 
     * @param {string} clusterId 
     * @param {string} addoninstallationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet(clusterId: string, addoninstallationId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet(clusterId, addoninstallationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the add-on installation. 
     * @param {string} clusterId 
     * @param {string} addoninstallationId 
     * @param {AddOnInstallation} [addOnInstallation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch(clusterId: string, addoninstallationId: string, addOnInstallation?: AddOnInstallation, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch(clusterId, addoninstallationId, addOnInstallation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of add-on installations. 
     * @param {string} clusterId 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to sort the add-on installations descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to retrieve all the add-on installations with a name starting with &#x60;my&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-on installations that the user has permission to see will be returned. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonsGet(clusterId: string, order?: string, page?: number, search?: string, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonsGet(clusterId, order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new add-on installation and add it to the collection of add-on installations on the cluster. 
     * @param {string} clusterId 
     * @param {AddOnInstallation} [addOnInstallation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonsPost(clusterId: string, addOnInstallation?: AddOnInstallation, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonsPost(clusterId, addOnInstallation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the AWS infrastructure access role grant. 
     * @param {string} clusterId 
     * @param {string} awsInfrastructureAccessRoleGrantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete(clusterId: string, awsInfrastructureAccessRoleGrantId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete(clusterId, awsInfrastructureAccessRoleGrantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the AWS infrastructure access role grant. 
     * @param {string} clusterId 
     * @param {string} awsInfrastructureAccessRoleGrantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet(clusterId: string, awsInfrastructureAccessRoleGrantId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet(clusterId, awsInfrastructureAccessRoleGrantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of AWS infrastructure access role grants. 
     * @param {string} clusterId 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to sort the AWS infrastructure access role grants descending by user ARN the value should be:   &#x60;&#x60;&#x60; user_arn desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to retrieve all the AWS infrastructure access role grants with a user ARN starting with &#x60;user&#x60; the value should be:   &#x60;&#x60;&#x60; user_arn like \&#39;%user\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the AWS infrastructure access role grants that the user has permission to see will be returned. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet(clusterId: string, order?: string, page?: number, search?: string, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet(clusterId, order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new AWS infrastructure access role grant and add it to the collection of AWS infrastructure access role grants on the cluster. 
     * @param {string} clusterId 
     * @param {AWSInfrastructureAccessRoleGrant} [aWSInfrastructureAccessRoleGrant] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost(clusterId: string, aWSInfrastructureAccessRoleGrant?: AWSInfrastructureAccessRoleGrant, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost(clusterId, aWSInfrastructureAccessRoleGrant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the credentials of a cluster. 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdCredentialsGet(clusterId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdCredentialsGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the cluster. 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdDelete(clusterId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdDelete(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the external configuration. 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet(clusterId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of labels. 
     * @param {string} clusterId 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {number} [size] Number of items contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet(clusterId: string, page?: number, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet(clusterId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the label. 
     * @param {string} clusterId 
     * @param {string} labelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete(clusterId: string, labelId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete(clusterId, labelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the label. 
     * @param {string} clusterId 
     * @param {string} labelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet(clusterId: string, labelId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet(clusterId, labelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the label. 
     * @param {string} clusterId 
     * @param {string} labelId 
     * @param {Label} [label] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch(clusterId: string, labelId: string, label?: Label, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch(clusterId, labelId, label, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new label to the cluster. 
     * @param {string} clusterId 
     * @param {Label} [label] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost(clusterId: string, label?: Label, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost(clusterId, label, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of syncsets. 
     * @param {string} clusterId 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {number} [size] Number of items contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet(clusterId: string, page?: number, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet(clusterId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new syncset to the cluster. 
     * @param {string} clusterId 
     * @param {Syncset} [syncset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost(clusterId: string, syncset?: Syncset, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost(clusterId, syncset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the syncset. 
     * @param {string} clusterId 
     * @param {string} syncsetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete(clusterId: string, syncsetId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete(clusterId, syncsetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the syncset. 
     * @param {string} clusterId 
     * @param {string} syncsetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet(clusterId: string, syncsetId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet(clusterId, syncsetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the syncset. 
     * @param {string} clusterId 
     * @param {string} syncsetId 
     * @param {Syncset} [syncset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch(clusterId: string, syncsetId: string, syncset?: Syncset, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch(clusterId, syncsetId, syncset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the cluster. 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGet(clusterId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of groups. 
     * @param {string} clusterId 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {number} [size] Number of items contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGroupsGet(clusterId: string, page?: number, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGroupsGet(clusterId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the group. 
     * @param {string} clusterId 
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet(clusterId: string, groupId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet(clusterId, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of users. 
     * @param {string} clusterId 
     * @param {string} groupId 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {number} [size] Number of items contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet(clusterId: string, groupId: string, page?: number, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet(clusterId, groupId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new user to the group. 
     * @param {string} clusterId 
     * @param {string} groupId 
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost(clusterId: string, groupId: string, user?: User, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost(clusterId, groupId, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the user. 
     * @param {string} clusterId 
     * @param {string} groupId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete(clusterId: string, groupId: string, userId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete(clusterId, groupId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the user. 
     * @param {string} clusterId 
     * @param {string} groupId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet(clusterId: string, groupId: string, userId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet(clusterId, groupId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiates cluster hibernation. While hibernating a cluster will not consume any cloud provider infrastructure but will be counted for quota. 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdHibernatePost(clusterId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdHibernatePost(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of identity providers. 
     * @param {string} clusterId 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {number} [size] Number of items contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet(clusterId: string, page?: number, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet(clusterId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the identity provider. 
     * @param {string} clusterId 
     * @param {string} identityProviderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete(clusterId: string, identityProviderId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete(clusterId, identityProviderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the identity provider. 
     * @param {string} clusterId 
     * @param {string} identityProviderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet(clusterId: string, identityProviderId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet(clusterId, identityProviderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update identity provider in the cluster. 
     * @param {string} clusterId 
     * @param {string} identityProviderId 
     * @param {IdentityProvider} [identityProvider] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch(clusterId: string, identityProviderId: string, identityProvider?: IdentityProvider, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch(clusterId, identityProviderId, identityProvider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new identity provider to the cluster. 
     * @param {string} clusterId 
     * @param {IdentityProvider} [identityProvider] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost(clusterId: string, identityProvider?: IdentityProvider, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost(clusterId, identityProvider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of ingresses. 
     * @param {string} clusterId 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {number} [size] Number of items contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIngressesGet(clusterId: string, page?: number, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIngressesGet(clusterId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the ingress. 
     * @param {string} clusterId 
     * @param {string} ingressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete(clusterId: string, ingressId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete(clusterId, ingressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the ingress. 
     * @param {string} clusterId 
     * @param {string} ingressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet(clusterId: string, ingressId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet(clusterId, ingressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the ingress. 
     * @param {string} clusterId 
     * @param {string} ingressId 
     * @param {Ingress} [ingress] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch(clusterId: string, ingressId: string, ingress?: Ingress, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch(clusterId, ingressId, ingress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates all ingresses 
     * @param {string} clusterId 
     * @param {Array<Ingress>} [ingress] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIngressesPatch(clusterId: string, ingress?: Array<Ingress>, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIngressesPatch(clusterId, ingress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new ingress to the cluster. 
     * @param {string} clusterId 
     * @param {Ingress} [ingress] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIngressesPost(clusterId: string, ingress?: Ingress, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIngressesPost(clusterId, ingress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of log links. 
     * @param {string} clusterId 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {number} [size] Number of items contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdLogsGet(clusterId: string, page?: number, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdLogsGet(clusterId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the log. 
     * @param {string} clusterId 
     * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log. 
     * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdLogsInstallGet(clusterId: string, offset?: number, tail?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdLogsInstallGet(clusterId, offset, tail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the log. 
     * @param {string} clusterId 
     * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log. 
     * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdLogsUninstallGet(clusterId: string, offset?: number, tail?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdLogsUninstallGet(clusterId, offset, tail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of machine pools. 
     * @param {string} clusterId 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {number} [size] Number of items contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMachinePoolsGet(clusterId: string, page?: number, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMachinePoolsGet(clusterId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the machine pool. 
     * @param {string} clusterId 
     * @param {string} machinePoolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete(clusterId: string, machinePoolId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete(clusterId, machinePoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the machine pool. 
     * @param {string} clusterId 
     * @param {string} machinePoolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet(clusterId: string, machinePoolId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet(clusterId, machinePoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the machine pool. 
     * @param {string} clusterId 
     * @param {string} machinePoolId 
     * @param {MachinePool} [machinePool] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch(clusterId: string, machinePoolId: string, machinePool?: MachinePool, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch(clusterId, machinePoolId, machinePool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new machine pool to the cluster. 
     * @param {string} clusterId 
     * @param {MachinePool} [machinePool] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMachinePoolsPost(clusterId: string, machinePool?: MachinePool, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMachinePoolsPost(clusterId, machinePool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet(clusterId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet(clusterId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the metrics. 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet(clusterId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet(clusterId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the metrics. 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet(clusterId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the cluster. 
     * @param {string} clusterId 
     * @param {Cluster} [cluster] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdPatch(clusterId: string, cluster?: Cluster, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdPatch(clusterId, cluster, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the product. 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdProductGet(clusterId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdProductGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the provision shard. 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdProvisionShardGet(clusterId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdProvisionShardGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resumes from Hibernation. 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdResumePost(clusterId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdResumePost(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdStatusGet(clusterId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdStatusGet(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of upgrade policies. 
     * @param {string} clusterId 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {number} [size] Number of items contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet(clusterId: string, page?: number, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet(clusterId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new upgrade policy to the cluster. 
     * @param {string} clusterId 
     * @param {UpgradePolicy} [upgradePolicy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost(clusterId: string, upgradePolicy?: UpgradePolicy, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost(clusterId, upgradePolicy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the upgrade policy. 
     * @param {string} clusterId 
     * @param {string} upgradePolicyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete(clusterId: string, upgradePolicyId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete(clusterId, upgradePolicyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the upgrade policy. 
     * @param {string} clusterId 
     * @param {string} upgradePolicyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet(clusterId: string, upgradePolicyId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet(clusterId, upgradePolicyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the upgrade policy. 
     * @param {string} clusterId 
     * @param {string} upgradePolicyId 
     * @param {UpgradePolicy} [upgradePolicy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch(clusterId: string, upgradePolicyId: string, upgradePolicy?: UpgradePolicy, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch(clusterId, upgradePolicyId, upgradePolicy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the upgrade policy state. 
     * @param {string} clusterId 
     * @param {string} upgradePolicyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet(clusterId: string, upgradePolicyId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet(clusterId, upgradePolicyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the upgrade policy state. 
     * @param {string} clusterId 
     * @param {string} upgradePolicyId 
     * @param {UpgradePolicyState} [upgradePolicyState] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch(clusterId: string, upgradePolicyId: string, upgradePolicyState?: UpgradePolicyState, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch(clusterId, upgradePolicyId, upgradePolicyState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of clusters. 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to sort the clusters descending by region identifier the value should be:   &#x60;&#x60;&#x60; region.id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to retrieve all the clusters with a name starting with &#x60;my&#x60; in the &#x60;us-east-1&#x60; region the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; and region.id &#x3D; \&#39;us-east-1\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersGet(order?: string, page?: number, search?: string, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersGet(order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provision a new cluster and add it to the collection of clusters.  See the `register_cluster` method for adding an existing cluster. 
     * @param {Cluster} [cluster] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersPost(cluster?: Cluster, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersPost(cluster, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the dashboard. 
     * @param {string} dashboardId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1DashboardsDashboardIdGet(dashboardId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1DashboardsDashboardIdGet(dashboardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of dashboards. 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the dashboard instead of the names of the columns of a table. For example, in order to sort the dashboards descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the dashboard instead of the names of the columns of a table. For example, in order to retrieve all the dashboards with a name starting with &#x60;my&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the dashboards that the user has permission to see will be returned. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1DashboardsGet(order?: string, page?: number, search?: string, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1DashboardsGet(order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the cluster flavour. 
     * @param {string} flavourId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1FlavoursFlavourIdGet(flavourId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1FlavoursFlavourIdGet(flavourId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the flavour.  Attributes that can be updated are:  - `aws.infra_volume` - `aws.infra_instance_type` - `gcp.infra_instance_type` 
     * @param {string} flavourId 
     * @param {Flavour} [flavour] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1FlavoursFlavourIdPatch(flavourId: string, flavour?: Flavour, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1FlavoursFlavourIdPatch(flavourId, flavour, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to sort the flavours descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to retrieve all the flavours with a name starting with &#x60;my&#x60;the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the flavours that the user has permission to see will be returned. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1FlavoursGet(order?: string, page?: number, search?: string, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1FlavoursGet(order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new cluster flavour. 
     * @param {Flavour} [flavour] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1FlavoursPost(flavour?: Flavour, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1FlavoursPost(flavour, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the version metadata. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1Get(options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1Get(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of machine types. 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to sort the machine types descending by name identifier the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to retrieve all the machine types with a name starting with &#x60;A&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the machine types that the user has permission to see will be returned. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1MachineTypesGet(order?: string, page?: number, search?: string, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1MachineTypesGet(order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of products. 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to sort the products descending by name the value should be:   &#x60;&#x60;&#x60; name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to retrieve all the products with a name starting with &#x60;my&#x60; the value should be:   &#x60;&#x60;&#x60; name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the products that the user has permission to see will be returned. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ProductsGet(order?: string, page?: number, search?: string, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ProductsGet(order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the product. 
     * @param {string} productId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ProductsProductIdGet(productId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ProductsProductIdGet(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ProvisionShardsGet(page?: number, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ProvisionShardsGet(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the provision shard. 
     * @param {string} provisionShardId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ProvisionShardsProvisionShardIdGet(provisionShardId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ProvisionShardsProvisionShardIdGet(provisionShardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of versions. 
     * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to sort the versions descending by identifier the value should be:   &#x60;&#x60;&#x60; id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined. 
     * @param {number} [page] Index of the requested page, where one corresponds to the first page. 
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to retrieve all the versions that are enabled:   &#x60;&#x60;&#x60; enabled &#x3D; \&#39;t\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the versions that the user has permission to see will be returned. 
     * @param {number} [size] Maximum number of items that will be contained in the returned page.  Default value is &#x60;100&#x60;. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1VersionsGet(order?: string, page?: number, search?: string, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1VersionsGet(order, page, search, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the version. 
     * @param {string} versionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1VersionsVersionIdGet(versionId: string, options?: any) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1VersionsVersionIdGet(versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new connector
     * @param {string} id The id of record
     * @param {boolean} async Perform the action in an asynchronous manner
     * @param {Connector} connector Connector data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createConnector(id: string, async: boolean, connector: Connector, options?: any) {
        return DefaultApiFp(this.configuration).createConnector(id, async, connector, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new connector cluster
     * @param {string} id The id of record
     * @param {boolean} async Perform the action in an asynchronous manner
     * @param {ConnectorCluster} connectorCluster Connector cluster data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createConnectorCluster(id: string, async: boolean, connectorCluster: ConnectorCluster, options?: any) {
        return DefaultApiFp(this.configuration).createConnectorCluster(id, async, connectorCluster, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new kafka Request
     * @param {boolean} async Perform the action in an asynchronous manner
     * @param {KafkaRequestPayload} kafkaRequestPayload Kafka data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createKafka(async: boolean, kafkaRequestPayload: KafkaRequestPayload, options?: any) {
        return DefaultApiFp(this.configuration).createKafka(async, kafkaRequestPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a service account
     * @param {ServiceAccountRequest} serviceAccountRequest service account request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createServiceAccount(serviceAccountRequest: ServiceAccountRequest, options?: any) {
        return DefaultApiFp(this.configuration).createServiceAccount(serviceAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a connector
     * @param {string} id The id of record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteConnector(id: string, options?: any) {
        return DefaultApiFp(this.configuration).deleteConnector(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a connector cluster
     * @param {string} id The id of record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteConnectorCluster(id: string, options?: any) {
        return DefaultApiFp(this.configuration).deleteConnectorCluster(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a kafka request by id
     * @param {string} id The id of record
     * @param {boolean} async Perform the action in an asynchronous manner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteKafkaById(id: string, async: boolean, options?: any) {
        return DefaultApiFp(this.configuration).deleteKafkaById(id, async, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete service account
     * @param {string} id The id of record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteServiceAccount(id: string, options?: any) {
        return DefaultApiFp(this.configuration).deleteServiceAccount(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a connector deployment
     * @param {string} id The id of record
     * @param {string} cid The id of the connector
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getConnector(id: string, cid: string, options?: any) {
        return DefaultApiFp(this.configuration).getConnector(id, cid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a connector cluster
     * @param {string} id The id of record
     * @param {string} cid The id of the connector cluster
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getConnectorCluster(id: string, cid: string, options?: any) {
        return DefaultApiFp(this.configuration).getConnectorCluster(id, cid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a connector cluster\'s addon parameters
     * @param {string} id The id of record
     * @param {string} cid The id of the connector cluster
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getConnectorClusterAddonParameters(id: string, cid: string, options?: any) {
        return DefaultApiFp(this.configuration).getConnectorClusterAddonParameters(id, cid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a connector type by name and version
     * @param {string} id The id of record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getConnectorTypeByID(id: string, options?: any) {
        return DefaultApiFp(this.configuration).getConnectorTypeByID(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the spec of the ManagedKafkaAgent CR spec
     * @param {string} id The id of record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getKafkaAgent(id: string, options?: any) {
        return DefaultApiFp(this.configuration).getKafkaAgent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a kafka request by id
     * @param {string} id The id of record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getKafkaById(id: string, options?: any) {
        return DefaultApiFp(this.configuration).getKafkaById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of ManagedaKafkas for the specified agent cluster
     * @param {string} id The id of record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getKafkas(id: string, options?: any) {
        return DefaultApiFp(this.configuration).getKafkas(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get metrics with instant query by kafka id.
     * @param {string} id The id of record
     * @param {Array<string>} [filters] List of metrics to fetch. Fetch all metrics when empty. List entries are kafka internal metric names.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMetricsByInstantQuery(id: string, filters?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).getMetricsByInstantQuery(id, filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get metrics with timeseries range query by kafka id.
     * @param {string} id The id of record
     * @param {number} duration The length of time in minutes over which to return the metrics.
     * @param {number} interval The interval in seconds between data points.
     * @param {Array<string>} [filters] List of metrics to fetch. Fetch all metrics when empty. List entries are kafka internal metric names.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMetricsByRangeQuery(id: string, duration: number, interval: number, filters?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).getMetricsByRangeQuery(id, duration, interval, filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get service account by id
     * @param {string} id The id of record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getServiceAccountById(id: string, options?: any) {
        return DefaultApiFp(this.configuration).getServiceAccountById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the list of supported regions of the supported cloud provider.
     * @param {string} id The id of record
     * @param {string} [page] Page index
     * @param {string} [size] Number of items in each page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listCloudProviderRegions(id: string, page?: string, size?: string, options?: any) {
        return DefaultApiFp(this.configuration).listCloudProviderRegions(id, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the list of supported cloud providers.
     * @param {string} [page] Page index
     * @param {string} [size] Number of items in each page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listCloudProviders(page?: string, size?: string, options?: any) {
        return DefaultApiFp(this.configuration).listCloudProviders(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of connector types
     * @param {string} id The id of record
     * @param {string} [page] Page index
     * @param {string} [size] Number of items in each page
     * @param {number} [gtVersion] filters the connectors to those with a version greater than the given value
     * @param {boolean} [watch] watch for changes to the resources and return them as a stream of watch events. Specify gt_version to specify the starting point.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listClusterAsignedConnectors(id: string, page?: string, size?: string, gtVersion?: number, watch?: boolean, options?: any) {
        return DefaultApiFp(this.configuration).listClusterAsignedConnectors(id, page, size, gtVersion, watch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of connector clusters
     * @param {string} id The id of record
     * @param {string} [page] Page index
     * @param {string} [size] Number of items in each page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listConnectorClusters(id: string, page?: string, size?: string, options?: any) {
        return DefaultApiFp(this.configuration).listConnectorClusters(id, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of connector types
     * @param {string} [page] Page index
     * @param {string} [size] Number of items in each page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listConnectorTypes(page?: string, size?: string, options?: any) {
        return DefaultApiFp(this.configuration).listConnectorTypes(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of connector types
     * @param {string} id The id of record
     * @param {string} [page] Page index
     * @param {string} [size] Number of items in each page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listConnectors(id: string, page?: string, size?: string, options?: any) {
        return DefaultApiFp(this.configuration).listConnectors(id, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of Kafka requests
     * @param {string} [page] Page index
     * @param {string} [size] Number of items in each page
     * @param {string} [orderBy] Specifies the order by criteria. The syntax of this parameter is similar to the syntax of the _order by_ clause of an SQL statement. Each query can be ordered by any of the kafkaRequests fields. For example, in order to retrieve all kafkas ordered by their name:  &#x60;&#x60;&#x60;sql name asc &#x60;&#x60;&#x60;  Or in order to retrieve all kafkas ordered by their name _and_ created date:  &#x60;&#x60;&#x60;sql name asc, created_at asc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the results will be ordered by name.
     * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement. Allowed fields in the search are: cloud_provider, name, owner, region and status. Allowed comparators are &#x60;&lt;&gt;&#x60;, &#x60;&#x3D;&#x60; or &#x60;LIKE&#x60;. Allowed joins are &#x60;AND&#x60; and &#x60;OR&#x60;, however there is a limit of max 10 joins in the search query.  Examples:  To retrieve kafka request with name equal &#x60;my-kafka&#x60; and region equal &#x60;aws&#x60;, the value should be:  &#x60;&#x60;&#x60; name &#x3D; my-kafka and cloud_provider &#x3D; aws &#x60;&#x60;&#x60;  To retrieve kafka request with its name starting with &#x60;my&#x60;, the value should be:  &#x60;&#x60;&#x60; name like my%25 &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the kafkas that the user has permission to see will be returned.  Note. If the query is invalid, an error will be returned 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listKafkas(page?: string, size?: string, orderBy?: string, search?: string, options?: any) {
        return DefaultApiFp(this.configuration).listKafkas(page, size, orderBy, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List service accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServiceAccounts(options?: any) {
        return DefaultApiFp(this.configuration).listServiceAccounts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary reset credentials for the service account
     * @param {string} id The id of record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resetServiceAccountCreds(id: string, options?: any) {
        return DefaultApiFp(this.configuration).resetServiceAccountCreds(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the status of resources e.g whether we have reached maximum service capacity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public serviceStatus(options?: any) {
        return DefaultApiFp(this.configuration).serviceStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the status of an agent cluster
     * @param {string} id The id of record
     * @param {DataPlaneClusterUpdateStatusRequest} dataPlaneClusterUpdateStatusRequest Cluster status update data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateAgentClusterStatus(id: string, dataPlaneClusterUpdateStatusRequest: DataPlaneClusterUpdateStatusRequest, options?: any) {
        return DefaultApiFp(this.configuration).updateAgentClusterStatus(id, dataPlaneClusterUpdateStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the status of Kafka clusters on an agent cluster
     * @param {string} id The id of record
     * @param {{ [key: string]: DataPlaneKafkaStatus; }} requestBody Kafka clusters status update data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateKafkaClusterStatus(id: string, requestBody: { [key: string]: DataPlaneKafkaStatus; }, options?: any) {
        return DefaultApiFp(this.configuration).updateKafkaClusterStatus(id, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the status of a connector agent cluster
     * @param {string} id The id of record
     * @param {ConnectorClusterUpdateStatus} connectorClusterUpdateStatus Cluster status update data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateKafkaConnectorAgentClusterStatus(id: string, connectorClusterUpdateStatus: ConnectorClusterUpdateStatus, options?: any) {
        return DefaultApiFp(this.configuration).updateKafkaConnectorAgentClusterStatus(id, connectorClusterUpdateStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the status of a connector agent cluster
     * @param {string} id The id of record
     * @param {string} cid The id of the connector
     * @param {ConnectorUpdateStatus} connectorUpdateStatus Cluster status update data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateKafkaConnectorStatus(id: string, cid: string, connectorUpdateStatus: ConnectorUpdateStatus, options?: any) {
        return DefaultApiFp(this.configuration).updateKafkaConnectorStatus(id, cid, connectorUpdateStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the version metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public versionMetadata(options?: any) {
        return DefaultApiFp(this.configuration).versionMetadata(options).then((request) => request(this.axios, this.basePath));
    }
}


